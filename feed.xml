<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://seulwithlove.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://seulwithlove.github.io/" rel="alternate" type="text/html" hreflang="ko"/><updated>2024-06-04T12:59:35+00:00</updated><id>https://seulwithlove.github.io/feed.xml</id><title type="html">Seul with Love</title><subtitle>A blog with Love </subtitle><entry><title type="html">SQLD 공부 실전문제 오답노트 - PART 1 - CH1. 데이터 모델링의 이해</title><link href="https://seulwithlove.github.io/blog/2024/get-sqld-exercise-5/" rel="alternate" type="text/html" title="SQLD 공부 실전문제 오답노트 - PART 1 - CH1. 데이터 모델링의 이해"/><published>2024-05-23T00:00:00+00:00</published><updated>2024-05-23T00:00:00+00:00</updated><id>https://seulwithlove.github.io/blog/2024/get-sqld-exercise-5</id><content type="html" xml:base="https://seulwithlove.github.io/blog/2024/get-sqld-exercise-5/"><![CDATA[<h2 id="sqld---week-5---실전문제-part1---1-데이터-모델링의-이해">SQLD - Week 5 - 실전문제 Part1 - 1. 데이터 모델링의 이해</h2> <h3 id="12번">12번</h3> <h4 id="발생시점에-따른-엔터티-분류">발생시점에 따른 엔터티 분류</h4> <ul> <li>기본 -&gt; 중심 -&gt; 행위 <ul> <li><strong>기본</strong> : 독립적으로 생성됨, 고유한 주식별자를 가짐 <ul> <li>업무에 원래 존재하는 정보</li> <li>자식 엔터티를 가질수 있음 <ul> <li>상품, 회원</li> </ul> </li> </ul> </li> <li><strong>중심</strong> : 기본 엔터티에서 파생, 행위 엔터티를 생성 <ul> <li>업무에서 핵심 역할을 함</li> <li>데이터 양이 많이 발생 <ul> <li>주문, 매출, 계약</li> </ul> </li> </ul> </li> <li><strong>행위</strong> : 2개 이상의 엔터티에서 파생 <ul> <li>자주 내용이 바뀌거나 데이터 양이 증가</li> <li>분석 초기 단계보다 상세 설계단계/프로세스와 상관모델링을 진행하면서 도출 <ul> <li>주문내역, 이벤트 응모 이력</li> </ul> </li> </ul> </li> </ul> </li> </ul> <h3 id="16번">16번</h3> <h4 id="정규화">정규화</h4> <ul> <li>2차 정규화 : 1차정규형을 만족하고, 모든 non-key 컬럼은 PK 전체에 종속되어야 함</li> </ul> <h3 id="19번">19번</h3> <h4 id="속성명-부여-주의사항">속성명 부여 주의사항</h4> <ul> <li>해당 업무에서 사용하는 이름 부여</li> <li>서술식 속성명은 사용X</li> <li>약어 사용은 가급적 제한</li> <li>전체 데이터 모델에서 유일성 확보</li> </ul> <h3 id="22번">22번</h3> <h4 id="3단계-스키마-구조">3단계 스키마 구조</h4> <ul> <li> <p>ANSI-SPARC에서 정의한 3단계 스키마 구조<br/> 1) 외부 스키마 : <u>View 단계</u>로 여러 사용자 관점으로 구성된 개인적 DB 스키마<br/> 2) 개념 스키마 : <u>모든 사용자 관점을 통합</u>한 전체 DB<br/> - 위 두 단계에서 논리적인 데이터 독립성을 고려<br/> 3) 내부 스키마 : 물리적인 저장구조 - 데이터 저장구조, 컬럼 정의, 인덱스 등<br/></p> </li> <li> <p>특징 : 데이터 독립성 보장</p> <ul> <li>논리적 독립성 : 개념 스키마 변경 -&gt; 외부 스키마 영향 X <ul> <li>논리적인 구조가 변경되어도 응용프로그램 영향도는 X</li> <li>사용자 특성에 맞게 변경 가능, 통합 구조의 변경도 가능</li> </ul> </li> <li>물리적 독립성 : 내부 스키마 변경 -&gt; 외부/개념 스키마 영향 X <ul> <li>데이터베이스 파일 구조의 변화가 논리스키마에 영향을 주지 X</li> <li>데이터베이스 색인구조 변화가 응용프로그램에 영향을 주지 X</li> </ul> </li> </ul> </li> </ul> <h3 id="25번">25번</h3> <h4 id="두-엔터티-사이의-관계를-도출할때-확인해야할-사항">두 엔터티 사이의 관계를 도출할때 확인해야할 사항</h4> <ul> <li>두 개의 엔터티 사이에 <strong>관심 있는 연관규칙이 존재</strong>하는가?</li> <li>두 개의 엔터티 사이에 <strong>정보의 조합이 발생</strong>하는가?</li> <li>업무기술서, 장표에 <strong>관계연결에 대한 규칙이 서술</strong>되어 있는가?</li> <li>업무기술서, 장표에 <strong>관계연결을 가능하게 하는 동사</strong>가 있는가?</li> </ul> <h3 id="27번">27번</h3> <h4 id="인조식별자">인조식별자</h4> <ul> <li>인위적으로 만들어지는 식별자 (꼭 필요하지 않지만 관리의 편이성 등의 이유로 인위적으로 만들어지는 식별자) <ul> <li>본질식별자가 복잡한 구성을 가질때 인위적으로 생성(후보 식별자중 PK로 선정할 만한게 없을때)</li> <li>꼭 필요한 경우에만 사용을 권장</li> </ul> </li> <li>주로 각 행을 구분하기 위한 기본키로 사용 <ul> <li>자동으로 증가하는 일련번호 같은 형태</li> <li>e.g. 매매 엔터티의 매매번호</li> </ul> </li> <li>참고: <a href="https://blog.cslee.co.kr/data-modelling/">블로그</a></li> </ul> <h3 id="28번">28번</h3> <ul> <li>이름은 동명이인이 있을수 있기떄문에 주식별자로 사용하기 부적합함</li> </ul> <h3 id="34번">34번</h3> <h4 id="함수-종속성-functional-dependency">함수 종속성 Functional Dependency</h4> <ul> <li>함수처럼 어떠한 값을 통해 종속 관계에 있는 다른 값을 유일하게 결정할수 있다 <ul> <li>e.g. 테이블에 [생일], [나이]라는 컬럼이 존재할때 <ul> <li>[나이]는 [생일]에 종속한다 : 생일을 알고 있으면 나이를 참조하지 않아도 나이를 결정할수 있음</li> </ul> </li> </ul> </li> <li>데이터베이스 설계단계에서 함수 종속 관계를 찾으면 중복된 데이터를 줄일수 있음</li> </ul> <h4 id="함수-종속의-성질암스트롱의-공리-armstrongs-axioms">함수 종속의 성질(암스트롱의 공리 Armstrong’s axioms)</h4> <ul> <li>augmentation : X → Y이면, XZ → YZ</li> <li>transitivity : X → Y이고 Y → Z이면, X → Z</li> <li>reflexivity : Y $\sub$ X, X → Y</li> <li>self-determination : X → X (자기 자신은 자신에 의해 함수 종속적이다)</li> <li>union : X → Y이고 X → Z이면, X → YZ</li> <li>decomposition : X → YZ이면, X → Y이고 X → Z</li> </ul> <h3 id="35번-40-41-44번">35번, 40, 41, 44번</h3> <h5 id="정규화-단계">정규화 단계</h5> <ol> <li>제1정규형(1 Normal Form: 1NF) : 엔터티의 모든 속성은 반드시 하나의 값만 가져야 한다 <ul> <li><u>유사한 속성이 반복</u>되면 -&gt; 1차 정규화!</li> <li>테이블의 컬럼은 하나의 값(원자값)을 갖도록 테이블 분해</li> </ul> </li> <li>제2정규형(2 Normal Form: 2NF) : 엔터티의 모든 속성은 반드시 모든 주식별자에 종속되어야한다 <ul> <li><u>어떤 속성이 일부 주식별자에만 종속</u>되어있다면 -&gt; 2차 정규화!</li> <li>부분 함수 종속성 제거 : 완전 함수 종속 만족 <ul> <li>릴레이션에서 종속자가 기본키가 아닌 다른 속성에 종속되거나, 기본키가 여러 속성으로 되어있을때 <ul> <li>기본키를 구성하는 속성 중 일부만 종속된 경우</li> </ul> </li> </ul> </li> </ul> </li> <li>제3정규형(3 Normal Form; 3NF) : 주식별자가 아닌 모든 속성간에는 서로 종속될수 없다 <ul> <li><u>2차 정규화를 진행한 테이블</u>에 <strong>이행적 종속</strong>이 없도록 테이블을 분해하는 것 <ul> <li>이행적 종속 : A → B, B → C 성립할때 A → C가 성립하는 것</li> </ul> </li> <li>이행함수 종속성 제거</li> <li><u>속성간에 종속</u>되어있다면 -&gt; 3차 정규화! <ul> <li>기본키가 있는데 일반속성이 일반속성을 결정하는 경우</li> </ul> </li> </ul> </li> <li>제4정규형 : 다중값 종속성 제거 -&gt; 4차 정규화!</li> </ol>]]></content><author><name></name></author><category term="study"/><category term="자격증"/><category term="sqld"/><category term="skill-stacking"/><summary type="html"><![CDATA[SQLD 5주차 공부 기록]]></summary></entry><entry><title type="html">SQLD 공부 실전문제 오답노트 - PART 2 - CH3. 관리구문</title><link href="https://seulwithlove.github.io/blog/2024/get-sqld-exercise-4/" rel="alternate" type="text/html" title="SQLD 공부 실전문제 오답노트 - PART 2 - CH3. 관리구문"/><published>2024-05-22T00:00:00+00:00</published><updated>2024-05-22T00:00:00+00:00</updated><id>https://seulwithlove.github.io/blog/2024/get-sqld-exercise-4</id><content type="html" xml:base="https://seulwithlove.github.io/blog/2024/get-sqld-exercise-4/"><![CDATA[<h2 id="sqld---week-5---실전문제-part2---3-관리구문">SQLD - Week 5 - 실전문제 Part2 - 3. 관리구문</h2> <h3 id="99번">99번</h3> <ul> <li>NULL / NOT NULL 잘 보기!</li> </ul> <h3 id="101번">101번</h3> <h4 id="tcltransaction-control-language-특성">TCL(Transaction Control Language) 특성</h4> <ul> <li>원자성(atomicity) : 트랜잭션 정의된 연산들 <strong>모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태</strong>로 남아 있어야 함 <ul> <li>모두 성공하거나 모두 실패하거나</li> </ul> </li> <li>일관성(consistency) : 트랜잭션 <strong>실행 전 데이터베이스 내용이 잘못되어 있지 않다면</strong> 트랜잭션 <strong>실행 이후에도 데이터베이스 내용의 잘못이 있으면 안됨</strong></li> <li>고립성(isolation) : <strong>트랜잭션 실행도중 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안됨</strong></li> <li>지속성(durability) : 트랜잭션이 성공적으로 수행되면 갱신한 데이터베이스 내용이 영구적으로 저장</li> </ul> <h3 id="107번">107번</h3> <ul> <li>PRIMARY KEY로 등록되면 자동으로 NOT NULL 속성을 가짐</li> </ul> <h3 id="108번">108번</h3> <h4 id="데이터-무결성integrity">데이터 무결성(integrity)</h4> <ul> <li>데이터의 정확성과 일관성을 유지하고, 데이터에 결손과 부정합이 없을을 보증</li> <li>참조 무결성 : 외래키 값은 NULL 이거나 참조 테이블의 기본키 값과 동일해야함 <ul> <li>외래키는 참조 테이블의 기본키에 정의된 데이터만 허용되는 구조이므로</li> </ul> </li> </ul> <h3 id="109번">109번</h3> <ul> <li>Natural key: an attribute that can uniquely identify a row, and exists in the real world.</li> <li>Surrogate key(대리키): an attribute that can uniquely identify a row, and does not exist in the real world.</li> <li>Composite key: more than one attribute that when combined can uniquely identify a row.</li> <li>Primary key(기본키): the single unique identifier for the row.</li> <li><strong>Candidate key(후보키): an attribute that could be the primary key.</strong> <ul> <li><strong>A candidate key</strong> is <strong>a key that uniquely identifies rows in a table.</strong></li> <li>Any of the identified candidate keys <u>can be used as the table's primary key.</u></li> <li>Candidate keys that are not part of the primary key are called alternate keys. <ul> <li>출처 : <a href="https://www.orafaq.com/wiki/Candidate_key">oraclefaq</a></li> </ul> </li> </ul> </li> <li>Alternate key: a candidate key that is not the primary key.</li> <li>Unique key: an attribute that can be unique on the table. Can also be called an alternate key.</li> <li>Foreign key(외래키): an attribute that is used to refer to another record in another table. <ul> <li>출처: <a href="https://www.databasestar.com/database-keys/#:~:text=Surrogate%20key%3A%20an%20attribute%20that,could%20be%20the%20primary%20key.">Databasestar</a></li> </ul> </li> </ul> <h3 id="110번">110번</h3> <ul> <li>DROP COLUMN : 컬럼 삭제 <ul> <li><code>ALTER TABLE table_name DROP COLUMN column_name;</code></li> </ul> </li> </ul> <h3 id="113번">113번</h3> <ul> <li>답지 259페이지 정리</li> </ul> <h3 id="115번">115번</h3> <ul> <li>묵시적 형변환(데이터 타입을 자동으로 변환) <ul> <li>VARCHAR2 → NUMBER</li> <li>VARCHAR2 → DATE</li> <li>NUMBER → VARCHAR2</li> <li>DATE → VARCHAR2</li> </ul> </li> </ul>]]></content><author><name></name></author><category term="study"/><category term="자격증"/><category term="sqld"/><category term="skill-stacking"/><summary type="html"><![CDATA[SQLD 5주차 공부 기록]]></summary></entry><entry><title type="html">SQLD 공부 실전문제 오답노트 - PART 2 - CH2. SQL 활용 - 2</title><link href="https://seulwithlove.github.io/blog/2024/get-sqld-exercise-3/" rel="alternate" type="text/html" title="SQLD 공부 실전문제 오답노트 - PART 2 - CH2. SQL 활용 - 2"/><published>2024-05-21T00:00:00+00:00</published><updated>2024-05-21T00:00:00+00:00</updated><id>https://seulwithlove.github.io/blog/2024/get-sqld-exercise-3</id><content type="html" xml:base="https://seulwithlove.github.io/blog/2024/get-sqld-exercise-3/"><![CDATA[<h2 id="sqld---week-5---실전문제-part2---2-sql-활용">SQLD - Week 5 - 실전문제 Part2 - 2. SQL 활용</h2> <ul> <li>&lt;<a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=332583104">SQL 자격검정 실전문제</a>&gt; (일명 노랭이) 개정판 1회독 + 오답노트 <ul> <li>출제 비중이 높은 Part 2 부터 시작</li> </ul> </li> <li>오답노트하며 중요한 개념 정리</li> </ul> <h3 id="61번">61번</h3> <ul> <li>계층형 질의에서 루트노드는 <strong>LEVEL 1</strong>부터 시작 <ul> <li>START WITH 절에 해당하는 행은 조건절과 상관없이 결과에 출력됨</li> </ul> </li> <li>START WITH 에서 지정한 행을 LEVEL 1로 지정 <ul> <li>홍길동, 이병헌 행이 LEVEL 1</li> </ul> </li> <li>CONNECT BY절의 PRIOR 바로 다음에 있는 컬럼을 기준으로 ‘=’ 이후의 컬럼과 맞췄을때 같은 데이터가 있는 행이 LEVEL 2 <ul> <li>사원번호 001, 005와 같은 매니저사원번호 행이 LEVEL 2</li> <li>남은 6명 모두 LEVEL 2 =&gt; 매니저만 두고 모두 동일 레벨</li> </ul> </li> </ul> <h3 id="64번">64번</h3> <ul> <li>WHERE 절은 계층형질의 전개 완료후에 필터링하기위한 조건절 <ul> <li>4번 FROM 절 안의 1)서브쿼리에서 <ul> <li>START WITH 2)서브쿼리 의 ‘START WITH~’ 전개 후에 나오는 결과에서 <ul> <li>WHERE 절에 해당하는 결과를 출력</li> <li>2)서브쿼리 결과: 100</li> </ul> </li> </ul> </li> </ul> </li> <li>LEFT OUTER JOIN - ON 이랑 세트</li> <li><em>한 세트(묶음끼리)를 잘 구분해서 정리</em></li> </ul> <h3 id="65번">65번</h3> <ul> <li><em>문제에서 테이블을 직접 만드는 경우 대략적으로 결과테이블 그려놓기</em></li> </ul> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>T1<span style="color: #bbbbbb"> </span>A,
<span style="color: #bbbbbb">     </span>T2<span style="color: #bbbbbb"> </span>B
</pre></div> <pre><code>쿼리 실행 결과:
</code></pre> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>NO</th> <th>COLA</th> <th>NO</th> <th>COLB</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>1</td> <td>AAA</td> <td>1</td> <td>BBB</td> </tr> <tr> <th>1</th> <td>1</td> <td>AAA</td> <td>3</td> <td>CCC</td> </tr> </tbody> </table> </div> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span>B.<span style="color: #008000; font-weight: bold">NO</span>,
<span style="color: #bbbbbb">       </span>A.COLA,
<span style="color: #bbbbbb">       </span>B.COLB
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>T1<span style="color: #bbbbbb"> </span>A
<span style="color: #008000; font-weight: bold">CROSS</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">JOIN</span><span style="color: #bbbbbb"> </span>T2<span style="color: #bbbbbb"> </span>B
</pre></div> <pre><code>쿼리 실행 결과:
</code></pre> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>NO</th> <th>COLA</th> <th>COLB</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>1</td> <td>AAA</td> <td>BBB</td> </tr> <tr> <th>1</th> <td>3</td> <td>AAA</td> <td>CCC</td> </tr> </tbody> </table> </div> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">NO</span>,
<span style="color: #bbbbbb">       </span>A.COLA,
<span style="color: #bbbbbb">       </span>B.COLB
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>T1<span style="color: #bbbbbb"> </span>A
<span style="color: #008000; font-weight: bold">NATURAL</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">JOIN</span><span style="color: #bbbbbb"> </span>T2<span style="color: #bbbbbb"> </span>B
</pre></div> <pre><code>쿼리 실행 결과:
</code></pre> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>NO</th> <th>COLA</th> <th>COLB</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>1</td> <td>AAA</td> <td>BBB</td> </tr> </tbody> </table> </div> <ul> <li>USING 절엔 ‘()’ 생략 불가!</li> <li>CROSS JOIN : 조건없이 조인할 경우 → 실행 가능한 모든 행 출력 <ul> <li>A.NO만 출력했기 때문에 ‘NO = 1’ 만 출력됨</li> </ul> </li> <li>NATURAL JOIN : 조인조건 없이 컬럼명이 같을때 사용 <ul> <li>조인조건 생략시 두 테이블에 같은 컬럼 이름이 있는 행을 연결(출력)</li> </ul> </li> </ul> <h3 id="66번">66번</h3> <ul> <li>셀프조인 SELF JOIN <ul> <li>테이블의 행을 하나씩 만들어감</li> </ul> </li> </ul> <h3 id="69번">69번</h3> <h4 id="윈도우함수">윈도우함수</h4> <ul> <li>RANK : 전체/특정 그룹 중 값의 순위 <ul> <li>값이 같으면 동일한 순위</li> <li>다음 순위는 동순위 개수에 따라 순위 부여 <ul> <li>e.g. 2순위 3개 → 다음 순위: 5순위</li> </ul> </li> </ul> </li> <li>DENSE_RANK : 누적순위 <ul> <li>값이 같으면 동일한 순위</li> <li>다음 순위는 앞 순위와 바로 이어지는 순위 부여 <ul> <li>e.g. 2순위 3개 → 다음 순위: 3순위</li> </ul> </li> </ul> </li> <li>CUME_DIST : 누적비율</li> <li>PERCENT_RANK : 분위수 <ul> <li>전체 COUNT 중 상대적 위치(0~1 범위 내)</li> </ul> </li> <li>RATIO_TO_REPORT : 각 값의 비율 리턴 <ul> <li>ORDER BY X</li> </ul> </li> <li>NTILE : 행을 특정 컬럼 순서에 따라 정해진 수(N)의 그룹으로 나누기 위한 함수 <ul> <li><code>SELECT NTILE(N) OVER ([PARTITION BY 컬럼] ORDER BY 컬럼 ASC | DESC)</code></li> <li>그룹 번호가 리턴</li> <li>ORDER BY 필수</li> </ul> </li> </ul> <h3 id="70번">70번</h3> <ul> <li>HAVING : GROUP BY 절의 필터링 조건절</li> </ul> <h4 id="select-1">SELECT 1</h4> <ul> <li>해당 테이블의 값을 1로 리턴</li> <li>WHERE 절에서 사용할 경우 조건을 만족하면 1 리턴 <ul> <li><code>WHERE EXISTS (SELECT 1 ...)</code></li> </ul> </li> <li>실제값이 아닌 ‘<strong>존재 유무</strong>‘가 중요할때 사용</li> </ul> <h4 id="where-0-의미">‘WHERE 0 &lt;’의미</h4> <ul> <li>서브쿼리에서 리턴하는 행이 있는지를 확인하기 위함</li> <li>리턴하는 행이 있으면 True : 해당 조건의 행 출력</li> <li>리턴하는 행이 없으면 False : 아무행도 출력하지 X</li> </ul> <h3 id="77번">77번</h3> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">사원</span>
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>사원ID</th> <th>부서ID</th> <th>연봉</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>1</td> <td>100</td> <td>2500</td> </tr> <tr> <th>1</th> <td>2</td> <td>100</td> <td>3000</td> </tr> <tr> <th>2</th> <td>3</td> <td>200</td> <td>4500</td> </tr> <tr> <th>3</th> <td>4</td> <td>200</td> <td>3000</td> </tr> <tr> <th>4</th> <td>5</td> <td>200</td> <td>2500</td> </tr> <tr> <th>5</th> <td>6</td> <td>300</td> <td>4500</td> </tr> <tr> <th>6</th> <td>7</td> <td>300</td> <td>3000</td> </tr> </tbody> </table> </div> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">사원</span>ID,
<span style="color: #bbbbbb">       </span>ROW_NUMBER()<span style="color: #bbbbbb"> </span>OVER<span style="color: #bbbbbb"> </span>(PARTITION<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">부서</span>ID
<span style="color: #bbbbbb">                          </span><span style="color: #008000; font-weight: bold">ORDER</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">연봉</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">DESC</span>)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AS</span><span style="color: #bbbbbb"> </span>COL1,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">SUM</span>(<span style="border: 1px solid #FF0000">연봉</span>)<span style="color: #bbbbbb"> </span>OVER<span style="color: #bbbbbb"> </span>(PARTITION<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">부서</span>ID
<span style="color: #bbbbbb">                     </span><span style="color: #008000; font-weight: bold">ORDER</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">사원</span>ID<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROWS</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BETWEEN</span><span style="color: #bbbbbb"> </span>UNBOUNDED<span style="color: #bbbbbb"> </span>PRECEDING<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AND</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">CURRENT</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROW</span>)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AS</span><span style="color: #bbbbbb"> </span>COL2,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">MAX</span>(<span style="border: 1px solid #FF0000">연봉</span>)<span style="color: #bbbbbb"> </span>OVER(
<span style="color: #bbbbbb">                    </span><span style="color: #008000; font-weight: bold">ORDER</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">연봉</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">DESC</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROWS</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">CURRENT</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROW</span>)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AS</span><span style="color: #bbbbbb"> </span>COL3
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">사원</span>
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>사원ID</th> <th>COL1</th> <th>COL2</th> <th>COL3</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>6</td> <td>1</td> <td>4500</td> <td>4500</td> </tr> <tr> <th>1</th> <td>3</td> <td>1</td> <td>4500</td> <td>4500</td> </tr> <tr> <th>2</th> <td>7</td> <td>2</td> <td>7500</td> <td>3000</td> </tr> <tr> <th>3</th> <td>2</td> <td>1</td> <td>5500</td> <td>3000</td> </tr> <tr> <th>4</th> <td>4</td> <td>2</td> <td>7500</td> <td>3000</td> </tr> <tr> <th>5</th> <td>1</td> <td>2</td> <td>2500</td> <td>2500</td> </tr> <tr> <th>6</th> <td>5</td> <td>3</td> <td>10000</td> <td>2500</td> </tr> </tbody> </table> </div> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">사원</span>ID,
<span style="color: #bbbbbb">       </span>COL2,
<span style="color: #bbbbbb">       </span>COL3
<span style="color: #008000; font-weight: bold">FROM</span>
<span style="color: #bbbbbb">  </span>(<span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">사원</span>ID,
<span style="color: #bbbbbb">          </span>ROW_NUMBER()<span style="color: #bbbbbb"> </span>OVER<span style="color: #bbbbbb"> </span>(PARTITION<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">부서</span>ID
<span style="color: #bbbbbb">                             </span><span style="color: #008000; font-weight: bold">ORDER</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">연봉</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">DESC</span>)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AS</span><span style="color: #bbbbbb"> </span>COL1,
<span style="color: #bbbbbb">          </span><span style="color: #008000; font-weight: bold">SUM</span>(<span style="border: 1px solid #FF0000">연봉</span>)<span style="color: #bbbbbb"> </span>OVER<span style="color: #bbbbbb"> </span>(PARTITION<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">부서</span>ID
<span style="color: #bbbbbb">                        </span><span style="color: #008000; font-weight: bold">ORDER</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">사원</span>ID<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROWS</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BETWEEN</span><span style="color: #bbbbbb"> </span>UNBOUNDED<span style="color: #bbbbbb"> </span>PRECEDING<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AND</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">CURRENT</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROW</span>)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AS</span><span style="color: #bbbbbb"> </span>COL2,
<span style="color: #bbbbbb">          </span><span style="color: #008000; font-weight: bold">MAX</span>(<span style="border: 1px solid #FF0000">연봉</span>)<span style="color: #bbbbbb"> </span>OVER(
<span style="color: #bbbbbb">                       </span><span style="color: #008000; font-weight: bold">ORDER</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">연봉</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">DESC</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROWS</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">CURRENT</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROW</span>)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AS</span><span style="color: #bbbbbb"> </span>COL3
<span style="color: #bbbbbb">   </span><span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">사원</span>)
<span style="color: #008000; font-weight: bold">WHERE</span><span style="color: #bbbbbb"> </span>COL1<span style="color: #666666">=2</span>
<span style="color: #008000; font-weight: bold">ORDER</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>사원ID</th> <th>COL2</th> <th>COL3</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>1</td> <td>2500</td> <td>2500</td> </tr> <tr> <th>1</th> <td>4</td> <td>7500</td> <td>3000</td> </tr> <tr> <th>2</th> <td>7</td> <td>7500</td> <td>3000</td> </tr> </tbody> </table> </div> <h4 id="rows-between-a-and-b-구문-파헤쳐보기"><code>ROWS BETWEEN A AND B</code> 구문 파헤쳐보기</h4> <ul> <li>UNBOUNDED PRECEDING, CURRENT ROW를 어떻게 구분하지? 현재 시점과 처음 시점은 어디를 기준으로 잡을까?</li> </ul> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">사원</span>ID,
<span style="color: #bbbbbb">       </span><span style="border: 1px solid #FF0000">부서</span>ID,
<span style="color: #bbbbbb">       </span><span style="border: 1px solid #FF0000">연봉</span>,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">SUM</span>(<span style="border: 1px solid #FF0000">연봉</span>)<span style="color: #bbbbbb"> </span>OVER<span style="color: #bbbbbb"> </span>(PARTITION<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">부서</span>ID
<span style="color: #bbbbbb">                     </span><span style="color: #008000; font-weight: bold">ORDER</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">사원</span>ID<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROWS</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BETWEEN</span><span style="color: #bbbbbb"> </span>UNBOUNDED<span style="color: #bbbbbb"> </span>PRECEDING<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AND</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">CURRENT</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROW</span>)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AS</span><span style="color: #bbbbbb"> </span>col2,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">SUM</span>(<span style="border: 1px solid #FF0000">연봉</span>)<span style="color: #bbbbbb"> </span>OVER<span style="color: #bbbbbb"> </span>(PARTITION<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">부서</span>ID
<span style="color: #bbbbbb">                     </span><span style="color: #008000; font-weight: bold">ORDER</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">사원</span>ID<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROWS</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BETWEEN</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">CURRENT</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROW</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AND</span><span style="color: #bbbbbb"> </span>UNBOUNDED<span style="color: #bbbbbb"> </span>FOLLOWING)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AS</span><span style="color: #bbbbbb"> </span>col2_2
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">사원</span>
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>사원ID</th> <th>부서ID</th> <th>연봉</th> <th>COL2</th> <th>COL2_2</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>1</td> <td>100</td> <td>2500</td> <td>2500</td> <td>5500</td> </tr> <tr> <th>1</th> <td>2</td> <td>100</td> <td>3000</td> <td>5500</td> <td>3000</td> </tr> <tr> <th>2</th> <td>3</td> <td>200</td> <td>4500</td> <td>4500</td> <td>10000</td> </tr> <tr> <th>3</th> <td>4</td> <td>200</td> <td>3000</td> <td>7500</td> <td>5500</td> </tr> <tr> <th>4</th> <td>5</td> <td>200</td> <td>2500</td> <td>10000</td> <td>2500</td> </tr> <tr> <th>5</th> <td>6</td> <td>300</td> <td>4500</td> <td>4500</td> <td>7500</td> </tr> <tr> <th>6</th> <td>7</td> <td>300</td> <td>3000</td> <td>7500</td> <td>3000</td> </tr> </tbody> </table> </div> <ul> <li>PARTITION된 영역 기준! <ul> <li>UNBOUNDED PRECEDING은 입력할 행의 위치와 상관없이 파티션된 영역의 첫번째 행을 의미</li> <li>CURRENT ROW는 데이터를 채워야할/입력할 행의 위치! : 계속 이동한다</li> </ul> </li> <li>COL2는 파티션영역내 첫행부터 현재행(이동위치)에 따라 합을 구하기떄문에 아래로 누적합 형태가 나오고,</li> <li>COL2-2는 현재행(이동위치)부터 파티션영역내 마지막 행까지의 합을 구하기때문에 합계가 점차 줄어드는 형태가 된다.</li> </ul> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">사원</span>ID,
<span style="color: #bbbbbb">       </span><span style="border: 1px solid #FF0000">연봉</span>
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">사원</span>
<span style="color: #008000; font-weight: bold">ORDER</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">연봉</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">DESC</span>
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>사원ID</th> <th>연봉</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>6</td> <td>4500</td> </tr> <tr> <th>1</th> <td>3</td> <td>4500</td> </tr> <tr> <th>2</th> <td>7</td> <td>3000</td> </tr> <tr> <th>3</th> <td>2</td> <td>3000</td> </tr> <tr> <th>4</th> <td>4</td> <td>3000</td> </tr> <tr> <th>5</th> <td>1</td> <td>2500</td> </tr> <tr> <th>6</th> <td>5</td> <td>2500</td> </tr> </tbody> </table> </div> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">사원</span>ID,
<span style="color: #bbbbbb">       </span>col3
<span style="color: #008000; font-weight: bold">FROM</span>
<span style="color: #bbbbbb">  </span>(<span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">사원</span>ID,
<span style="color: #bbbbbb">          </span><span style="color: #008000; font-weight: bold">max</span>(<span style="border: 1px solid #FF0000">연봉</span>)<span style="color: #bbbbbb"> </span>over(
<span style="color: #bbbbbb">                       </span><span style="color: #008000; font-weight: bold">ORDER</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">연봉</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">DESC</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROWS</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">CURRENT</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROW</span>)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AS</span><span style="color: #bbbbbb"> </span>col3
<span style="color: #bbbbbb">   </span><span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span><span style="border: 1px solid #FF0000">사원</span>)
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>사원ID</th> <th>COL3</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>6</td> <td>4500</td> </tr> <tr> <th>1</th> <td>3</td> <td>4500</td> </tr> <tr> <th>2</th> <td>7</td> <td>3000</td> </tr> <tr> <th>3</th> <td>2</td> <td>3000</td> </tr> <tr> <th>4</th> <td>4</td> <td>3000</td> </tr> <tr> <th>5</th> <td>1</td> <td>2500</td> </tr> <tr> <th>6</th> <td>5</td> <td>2500</td> </tr> </tbody> </table> </div> <ul> <li><code>ROWS CURRENT ROW</code> : <code>BETWEEN</code>+ <code>AND CURRENT ROW</code> 가 생략된것 <ul> <li>= <code>ROWS BETWEEN CURRENT ROW AND CURRENT ROW</code></li> </ul> </li> <li>결국 현재 행 내에서 MAX(연봉)을 구하기때문에 해당 행의 연봉이 그대로 출력된다</li> </ul> <h3 id="78번">78번</h3> <h4 id="grouping-함수">GROUPING 함수</h4> <ul> <li><a href="https://learn.microsoft.com/en-us/sql/t-sql/functions/grouping-transact-sql?view=sql-server-ver16">Microsoft Learn의 SQL Server 페이지 설명</a>은 다음과 같음 <blockquote> <p>Indicates whether <strong>a specified column expression in a GROUP BY list is aggregated or not.</strong><br/> GROUPING returns 1 for aggregated or 0 for not aggregated in the result set.<br/>GROUPING can be used only in the SELECT &lt;select&gt; list, HAVING, and ORDER BY clauses when GROUP BY is specified.</p> </blockquote> </li> <li>공식 정의에 따르면 ‘GROUP BY 절에서 지정한 컬럼에 대한 집계생성 여부를 반환한다’는 의미 <ul> <li>해당 컬럼이 집계되었다면 0, 그 외 1</li> </ul> </li> <li>ROLLUP, CUBE, GROUPING SETS 함수가 리턴하는 NULL과 일반 NULL을 구분하기 위해 사용 <ul> <li>위 함수들이 리턴하는 NULL은 column placeholder 역할을 함</li> </ul> </li> <li>하지만 이 설명은 뭔가 복잡함. 그래서 대부분 아래처럼 정의하는 듯함. 직관적으로 이해는 되지만 어쨌든 GROUPING 함수의 용도를 잘 기억하자! <br/></li> <li>GROUP BY 결과로 “NULL이 생성된 경우” 1을 리턴하는 함수 <ul> <li>GROUP BY 결과에 NULL이 있으면 : 1</li> </ul> </li> <li>GROUP BY 절 필수! <ul> <li>위 조건을 충족하면, SELECT 절 / HAVING 절 / ORDER BY 절에서만 사용가능</li> </ul> </li> <li><em>MIN(B.지역명)은 아직 이해가 안됨…😣</em></li> </ul> <h3 id="79번">79번</h3> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span>empno,
<span style="color: #bbbbbb">       </span>sal
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>emp
<span style="color: #008000; font-weight: bold">WHERE</span><span style="color: #bbbbbb"> </span>sal<span style="color: #bbbbbb"> </span><span style="color: #666666">&gt;=</span>
<span style="color: #bbbbbb">    </span>(<span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">max</span>(sal)
<span style="color: #bbbbbb">     </span><span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>emp
<span style="color: #bbbbbb">     </span><span style="color: #008000; font-weight: bold">GROUP</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span>deptno)
</pre></div> <pre><code>쿼리 실행 중 오류 발생:
ORA-01427: single-row subquery returns more than one row
Help: https://docs.oracle.com/error-help/db/ora-01427/
</code></pre> <h3 id="80번">80번</h3> <ul> <li><em>GROUP BY FUNCTION 종류별로 정리 꼼꼼히!!</em> <ul> <li>여러 GROUP BY 결과를 동시에 출력(합집합)</li> </ul> </li> </ul> <h4 id="grouping-setsa-b-">GROUPING SETS(A, B, …)</h4> <ul> <li>A, B별 그룹 연산 결과 출력 <ul> <li>GROUPING SETS에 나열한 대상에 대해 <strong>각 GROUP BY 결과</strong>를 출력</li> </ul> </li> <li>나열 순서 중요하지X</li> <li><strong>전체 총계는 출력X</strong> <ul> <li>전체 총계 출력하려면 : NULL 혹은 <code>()</code> 사용</li> </ul> </li> <li>’= UNION ALL’ : 빈 컬럼 NULL로 맞춰줘야함</li> </ul> <h4 id="rollupa-b">ROLLUP(A, B)</h4> <ul> <li>A별, (A, B)별, 전체 그룹 연산 결과 출력</li> <li>나열 대상의 <strong>순서</strong> 중요! <ul> <li>나열된 컬럼의 계층 구조로 집계 출력</li> </ul> </li> <li>UNION ALL로 대체 가능 : 빈 컬럼 NULL로 맞춰줘야함</li> </ul> <h4 id="cubeab">CUBE(A,B)</h4> <ul> <li>A별, (A, B)별, 전체 그룹 연산 결과 출력</li> <li>모든 조합의 경우의 수 모두 출력</li> <li>나열 대상의 순서 중요X</li> <li>UNION ALL, GROUPING SETS로 대체 가능</li> </ul> <h3 id="82번">82번</h3> <ul> <li>원래 ROLLUP (JOB, DEPTNO)를 하면 다음처럼 주어진 컬럼명 나열순을 기준으로 레벨별 집계가 반환된다</li> </ul> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span>A.JOB,
<span style="color: #bbbbbb">       </span>A.DEPTNO,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">SUM</span>(SAL)
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>EMP<span style="color: #bbbbbb"> </span>A
<span style="color: #008000; font-weight: bold">GROUP</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROLLUP</span><span style="color: #bbbbbb"> </span>(JOB,
<span style="color: #bbbbbb">                 </span>DEPTNO)
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>JOB</th> <th>DEPTNO</th> <th>SUM(SAL)</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>CLERK</td> <td>20.0</td> <td>1900</td> </tr> <tr> <th>1</th> <td>SALESMAN</td> <td>30.0</td> <td>5600</td> </tr> <tr> <th>2</th> <td>MANAGER</td> <td>20.0</td> <td>2975</td> </tr> <tr> <th>3</th> <td>MANAGER</td> <td>30.0</td> <td>2850</td> </tr> <tr> <th>4</th> <td>MANAGER</td> <td>10.0</td> <td>2450</td> </tr> <tr> <th>5</th> <td>ANALYST</td> <td>20.0</td> <td>6000</td> </tr> <tr> <th>6</th> <td>PRESIDENT</td> <td>10.0</td> <td>5000</td> </tr> <tr> <th>7</th> <td>CLERK</td> <td>30.0</td> <td>950</td> </tr> <tr> <th>8</th> <td>CLERK</td> <td>10.0</td> <td>1300</td> </tr> <tr> <th>9</th> <td>CLERK</td> <td>NaN</td> <td>4150</td> </tr> <tr> <th>10</th> <td>SALESMAN</td> <td>NaN</td> <td>5600</td> </tr> <tr> <th>11</th> <td>MANAGER</td> <td>NaN</td> <td>8275</td> </tr> <tr> <th>12</th> <td>ANALYST</td> <td>NaN</td> <td>6000</td> </tr> <tr> <th>13</th> <td>PRESIDENT</td> <td>NaN</td> <td>5000</td> </tr> <tr> <th>14</th> <td>None</td> <td>NaN</td> <td>29025</td> </tr> </tbody> </table> </div> <ul> <li>하지만 <code>ROLLUP ((A, B))</code> 이런식으로 괄호를 두 번 감싸면 컬럼별 집계와 맨 마지막 전체 집계만 출력가능</li> </ul> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span>A.JOB,
<span style="color: #bbbbbb">       </span>A.DEPTNO,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">SUM</span>(SAL)
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>EMP<span style="color: #bbbbbb"> </span>A
<span style="color: #008000; font-weight: bold">GROUP</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROLLUP</span><span style="color: #bbbbbb"> </span>((JOB,
<span style="color: #bbbbbb">                  </span>DEPTNO))
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>JOB</th> <th>DEPTNO</th> <th>SUM(SAL)</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>CLERK</td> <td>20.0</td> <td>1900</td> </tr> <tr> <th>1</th> <td>SALESMAN</td> <td>30.0</td> <td>5600</td> </tr> <tr> <th>2</th> <td>MANAGER</td> <td>20.0</td> <td>2975</td> </tr> <tr> <th>3</th> <td>MANAGER</td> <td>30.0</td> <td>2850</td> </tr> <tr> <th>4</th> <td>MANAGER</td> <td>10.0</td> <td>2450</td> </tr> <tr> <th>5</th> <td>ANALYST</td> <td>20.0</td> <td>6000</td> </tr> <tr> <th>6</th> <td>PRESIDENT</td> <td>10.0</td> <td>5000</td> </tr> <tr> <th>7</th> <td>CLERK</td> <td>30.0</td> <td>950</td> </tr> <tr> <th>8</th> <td>CLERK</td> <td>10.0</td> <td>1300</td> </tr> <tr> <th>9</th> <td>None</td> <td>NaN</td> <td>29025</td> </tr> </tbody> </table> </div> <ul> <li>문제에서는 평균값을 출력하는 행 하나만 있기때문에 괄호 2개로 전체 총합 소계만 출력하는게 필요</li> </ul> <h3 id="83번">83번</h3> <ul> <li><code>GROUPING SETS ((A, B))</code> : A, B 두개의 컬럼을 그룹으로 만들어 소계를 집계 <ul> <li><code>GROUP BY A, B</code> 와 동일한 결과</li> </ul> </li> <li>참고 : <a href="https://gent.tistory.com/279">블로그</a></li> </ul> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span>job,
<span style="color: #bbbbbb">       </span>deptno,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">count</span>(<span style="color: #666666">*</span>)<span style="color: #bbbbbb"> </span>cnt
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>emp
<span style="color: #008000; font-weight: bold">GROUP</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">GROUPING</span>
<span style="color: #008000; font-weight: bold">SETS</span><span style="color: #bbbbbb"> </span>((job,
<span style="color: #bbbbbb">       </span>deptno))
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>JOB</th> <th>DEPTNO</th> <th>CNT</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>CLERK</td> <td>20</td> <td>2</td> </tr> <tr> <th>1</th> <td>SALESMAN</td> <td>30</td> <td>4</td> </tr> <tr> <th>2</th> <td>MANAGER</td> <td>20</td> <td>1</td> </tr> <tr> <th>3</th> <td>MANAGER</td> <td>30</td> <td>1</td> </tr> <tr> <th>4</th> <td>MANAGER</td> <td>10</td> <td>1</td> </tr> <tr> <th>5</th> <td>ANALYST</td> <td>20</td> <td>2</td> </tr> <tr> <th>6</th> <td>PRESIDENT</td> <td>10</td> <td>1</td> </tr> <tr> <th>7</th> <td>CLERK</td> <td>30</td> <td>1</td> </tr> <tr> <th>8</th> <td>CLERK</td> <td>10</td> <td>1</td> </tr> </tbody> </table> </div> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span>job,
<span style="color: #bbbbbb">       </span>deptno,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">count</span>(<span style="color: #666666">*</span>)<span style="color: #bbbbbb"> </span>cnt
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>emp
<span style="color: #008000; font-weight: bold">GROUP</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span>job,
<span style="color: #bbbbbb">         </span>deptno
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>JOB</th> <th>DEPTNO</th> <th>CNT</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>CLERK</td> <td>20</td> <td>2</td> </tr> <tr> <th>1</th> <td>SALESMAN</td> <td>30</td> <td>4</td> </tr> <tr> <th>2</th> <td>MANAGER</td> <td>20</td> <td>1</td> </tr> <tr> <th>3</th> <td>MANAGER</td> <td>30</td> <td>1</td> </tr> <tr> <th>4</th> <td>MANAGER</td> <td>10</td> <td>1</td> </tr> <tr> <th>5</th> <td>ANALYST</td> <td>20</td> <td>2</td> </tr> <tr> <th>6</th> <td>PRESIDENT</td> <td>10</td> <td>1</td> </tr> <tr> <th>7</th> <td>CLERK</td> <td>30</td> <td>1</td> </tr> <tr> <th>8</th> <td>CLERK</td> <td>10</td> <td>1</td> </tr> </tbody> </table> </div> <ul> <li><code>GROUPING SETS (A, B)</code> 는 명시된 컬럼별 소계를 출력함</li> </ul> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span>job,
<span style="color: #bbbbbb">       </span>deptno,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">count</span>(<span style="color: #666666">*</span>)<span style="color: #bbbbbb"> </span>cnt
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>emp
<span style="color: #008000; font-weight: bold">GROUP</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">GROUPING</span>
<span style="color: #008000; font-weight: bold">SETS</span><span style="color: #bbbbbb"> </span>(Job,
<span style="color: #bbbbbb">      </span>deptno)
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>JOB</th> <th>DEPTNO</th> <th>CNT</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>None</td> <td>10.0</td> <td>3</td> </tr> <tr> <th>1</th> <td>None</td> <td>20.0</td> <td>5</td> </tr> <tr> <th>2</th> <td>None</td> <td>30.0</td> <td>6</td> </tr> <tr> <th>3</th> <td>PRESIDENT</td> <td>NaN</td> <td>1</td> </tr> <tr> <th>4</th> <td>MANAGER</td> <td>NaN</td> <td>3</td> </tr> <tr> <th>5</th> <td>SALESMAN</td> <td>NaN</td> <td>4</td> </tr> <tr> <th>6</th> <td>ANALYST</td> <td>NaN</td> <td>2</td> </tr> <tr> <th>7</th> <td>CLERK</td> <td>NaN</td> <td>4</td> </tr> </tbody> </table> </div> <h3 id="85번">85번</h3> <ul> <li>RANK : 동순위 데이터 수에 따라 다음 순위 결정됨</li> <li>DENSE_RANK : 누적순위 - 동순위 다음 순위가 바로 이어짐</li> <li>ROW_NUMBER : 연속된 행번호 - 동순위 인정X, 나열 순서대로 순서 값 출력</li> </ul> <h3 id="90번">90번</h3> <h4 id="lag">LAG</h4> <ul> <li>바로 이전 행 결과 출력 <h4 id="lead">LEAD</h4> </li> <li>바로 다음 행 결과 출력</li> </ul> <h3 id="91번">91번</h3> <h4 id="권한-부여-옵션---중간관리자-권한">권한 부여 옵션 - 중간관리자 권한</h4> <ul> <li><strong>WITH GRANT OPTION</strong> : <u>오브젝트 권한을 다른 사용자에게 부여</u> -&gt; 이 사용자는 <code>중간관리자</code>가 됨 <ul> <li>중간관리자가 부여한 권한은 중간관리자만 회수 가능</li> <li>중간관리자에게 부여된 권한 회수 시 제 3 자에게 부여된 권한도 함께 회수됨</li> </ul> </li> <li><strong>WITH ADMIN OPTION</strong> : <u>시스템 권한/롤 권한을 다른 사용자에게 부여 가능</u> -&gt; 이 사용자는 <code>중간관리자</code>가 됨 <ul> <li>중간관리자를 거치지 않고 직접 회수 O</li> <li>중간관리자 권한 회수 : 제3자에게 부여된 권한 함께 회수 X(남아있음)</li> </ul> </li> </ul> <h3 id="96번">96번</h3> <ul> <li>INTERSECT : SQL 결과에 대한 교집합 출력 <ul> <li>중복된 행은 하나만 출력</li> </ul> </li> </ul> <h3 id="97번">97번</h3> <h4 id="lag-1">LAG</h4> <ul> <li><code>LAG (scalar_expression [, offset [, default ]]) OVER ( [ partition_by_clause ] order_by_clause)</code> <ul> <li>offset : The number of rows back from the current row from which to obtain a value. If not specified, the default is 1.</li> </ul> </li> <li>출처 : <a href="https://www.geeksforgeeks.org/sql-server-lag-function-overview/">Geeksforgeeks</a></li> </ul>]]></content><author><name></name></author><category term="study"/><category term="자격증"/><category term="sqld"/><category term="skill-stacking"/><summary type="html"><![CDATA[SQLD 5주차 공부 기록]]></summary></entry><entry><title type="html">SQLD 공부 실전문제 오답노트 - PART 2 - CH2. SQL 활용 - 1</title><link href="https://seulwithlove.github.io/blog/2024/get-sqld-exercise-2/" rel="alternate" type="text/html" title="SQLD 공부 실전문제 오답노트 - PART 2 - CH2. SQL 활용 - 1"/><published>2024-05-20T00:00:00+00:00</published><updated>2024-05-20T00:00:00+00:00</updated><id>https://seulwithlove.github.io/blog/2024/get-sqld-exercise-2</id><content type="html" xml:base="https://seulwithlove.github.io/blog/2024/get-sqld-exercise-2/"><![CDATA[<h2 id="sqld---week-5---실전문제-part2---2-sql-활용">SQLD - Week 5 - 실전문제 Part2 - 2. SQL 활용</h2> <ul> <li>&lt;<a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=332583104">SQL 자격검정 실전문제</a>&gt; (일명 노랭이) 개정판 1회독 + 오답노트 <ul> <li>출제 비중이 높은 Part 2 부터 시작</li> </ul> </li> <li>오답노트하며 중요한 개념 정리</li> </ul> <h3 id="51번">51번</h3> <ul> <li>서브쿼리 종류</li> </ul> <h3 id="52번">52번</h3> <ul> <li>UNION ALL</li> <li>GROUPING SETS</li> <li>ROLLUP</li> <li>CUBE</li> </ul> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span>ENAME,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">SUM</span>(SAL)
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>EMP
<span style="color: #008000; font-weight: bold">GROUP</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span>ENAME
<span style="color: #008000; font-weight: bold">UNION</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ALL</span>
<span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">NULL</span>,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">SUM</span>(SAL)
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>EMP
<span style="color: #008000; font-weight: bold">ORDER</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ASC</span>
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>ENAME</th> <th>SUM(SAL)</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>ADAMS</td> <td>1100</td> </tr> <tr> <th>1</th> <td>ALLEN</td> <td>1600</td> </tr> <tr> <th>2</th> <td>BLAKE</td> <td>2850</td> </tr> <tr> <th>3</th> <td>CLARK</td> <td>2450</td> </tr> <tr> <th>4</th> <td>FORD</td> <td>3000</td> </tr> <tr> <th>5</th> <td>JAMES</td> <td>950</td> </tr> <tr> <th>6</th> <td>JONES</td> <td>2975</td> </tr> <tr> <th>7</th> <td>KING</td> <td>5000</td> </tr> <tr> <th>8</th> <td>MARTIN</td> <td>1250</td> </tr> <tr> <th>9</th> <td>MILLER</td> <td>1300</td> </tr> <tr> <th>10</th> <td>SCOTT</td> <td>3000</td> </tr> <tr> <th>11</th> <td>SMITH</td> <td>800</td> </tr> <tr> <th>12</th> <td>TURNER</td> <td>1500</td> </tr> <tr> <th>13</th> <td>WARD</td> <td>1250</td> </tr> <tr> <th>14</th> <td>None</td> <td>29025</td> </tr> </tbody> </table> </div> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span>ENAME,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">SUM</span>(SAL)
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>EMP
<span style="color: #008000; font-weight: bold">GROUP</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">GROUPING</span>
<span style="color: #008000; font-weight: bold">SETS</span><span style="color: #bbbbbb"> </span>(ENAME)
<span style="color: #008000; font-weight: bold">ORDER</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ASC</span>
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>ENAME</th> <th>SUM(SAL)</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>ADAMS</td> <td>1100</td> </tr> <tr> <th>1</th> <td>ALLEN</td> <td>1600</td> </tr> <tr> <th>2</th> <td>BLAKE</td> <td>2850</td> </tr> <tr> <th>3</th> <td>CLARK</td> <td>2450</td> </tr> <tr> <th>4</th> <td>FORD</td> <td>3000</td> </tr> <tr> <th>5</th> <td>JAMES</td> <td>950</td> </tr> <tr> <th>6</th> <td>JONES</td> <td>2975</td> </tr> <tr> <th>7</th> <td>KING</td> <td>5000</td> </tr> <tr> <th>8</th> <td>MARTIN</td> <td>1250</td> </tr> <tr> <th>9</th> <td>MILLER</td> <td>1300</td> </tr> <tr> <th>10</th> <td>SCOTT</td> <td>3000</td> </tr> <tr> <th>11</th> <td>SMITH</td> <td>800</td> </tr> <tr> <th>12</th> <td>TURNER</td> <td>1500</td> </tr> <tr> <th>13</th> <td>WARD</td> <td>1250</td> </tr> </tbody> </table> </div> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span>ENAME,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">SUM</span>(SAL)
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>EMP
<span style="color: #008000; font-weight: bold">GROUP</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROLLUP</span><span style="color: #bbbbbb"> </span>(ENAME)
<span style="color: #008000; font-weight: bold">ORDER</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ASC</span>
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>ENAME</th> <th>SUM(SAL)</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>ADAMS</td> <td>1100</td> </tr> <tr> <th>1</th> <td>ALLEN</td> <td>1600</td> </tr> <tr> <th>2</th> <td>BLAKE</td> <td>2850</td> </tr> <tr> <th>3</th> <td>CLARK</td> <td>2450</td> </tr> <tr> <th>4</th> <td>FORD</td> <td>3000</td> </tr> <tr> <th>5</th> <td>JAMES</td> <td>950</td> </tr> <tr> <th>6</th> <td>JONES</td> <td>2975</td> </tr> <tr> <th>7</th> <td>KING</td> <td>5000</td> </tr> <tr> <th>8</th> <td>MARTIN</td> <td>1250</td> </tr> <tr> <th>9</th> <td>MILLER</td> <td>1300</td> </tr> <tr> <th>10</th> <td>SCOTT</td> <td>3000</td> </tr> <tr> <th>11</th> <td>SMITH</td> <td>800</td> </tr> <tr> <th>12</th> <td>TURNER</td> <td>1500</td> </tr> <tr> <th>13</th> <td>WARD</td> <td>1250</td> </tr> <tr> <th>14</th> <td>None</td> <td>29025</td> </tr> </tbody> </table> </div> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span>ENAME,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">SUM</span>(SAL)
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>EMP
<span style="color: #008000; font-weight: bold">GROUP</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">CUBE</span><span style="color: #bbbbbb"> </span>(ENAME)
<span style="color: #008000; font-weight: bold">ORDER</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ASC</span>
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>ENAME</th> <th>SUM(SAL)</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>ADAMS</td> <td>1100</td> </tr> <tr> <th>1</th> <td>ALLEN</td> <td>1600</td> </tr> <tr> <th>2</th> <td>BLAKE</td> <td>2850</td> </tr> <tr> <th>3</th> <td>CLARK</td> <td>2450</td> </tr> <tr> <th>4</th> <td>FORD</td> <td>3000</td> </tr> <tr> <th>5</th> <td>JAMES</td> <td>950</td> </tr> <tr> <th>6</th> <td>JONES</td> <td>2975</td> </tr> <tr> <th>7</th> <td>KING</td> <td>5000</td> </tr> <tr> <th>8</th> <td>MARTIN</td> <td>1250</td> </tr> <tr> <th>9</th> <td>MILLER</td> <td>1300</td> </tr> <tr> <th>10</th> <td>SCOTT</td> <td>3000</td> </tr> <tr> <th>11</th> <td>SMITH</td> <td>800</td> </tr> <tr> <th>12</th> <td>TURNER</td> <td>1500</td> </tr> <tr> <th>13</th> <td>WARD</td> <td>1250</td> </tr> <tr> <th>14</th> <td>None</td> <td>29025</td> </tr> </tbody> </table> </div> <ul> <li>GROUPING SETS에서 전체 그룹 연산 결과 출력하려면 <code>()</code> 꼭 포함해야함</li> </ul> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span>ENAME,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">SUM</span>(SAL)
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>EMP
<span style="color: #008000; font-weight: bold">GROUP</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">GROUPING</span>
<span style="color: #008000; font-weight: bold">SETS</span><span style="color: #bbbbbb"> </span>(ENAME,<span style="color: #bbbbbb"> </span>())
<span style="color: #008000; font-weight: bold">ORDER</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ASC</span>
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>ENAME</th> <th>SUM(SAL)</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>ADAMS</td> <td>1100</td> </tr> <tr> <th>1</th> <td>ALLEN</td> <td>1600</td> </tr> <tr> <th>2</th> <td>BLAKE</td> <td>2850</td> </tr> <tr> <th>3</th> <td>CLARK</td> <td>2450</td> </tr> <tr> <th>4</th> <td>FORD</td> <td>3000</td> </tr> <tr> <th>5</th> <td>JAMES</td> <td>950</td> </tr> <tr> <th>6</th> <td>JONES</td> <td>2975</td> </tr> <tr> <th>7</th> <td>KING</td> <td>5000</td> </tr> <tr> <th>8</th> <td>MARTIN</td> <td>1250</td> </tr> <tr> <th>9</th> <td>MILLER</td> <td>1300</td> </tr> <tr> <th>10</th> <td>SCOTT</td> <td>3000</td> </tr> <tr> <th>11</th> <td>SMITH</td> <td>800</td> </tr> <tr> <th>12</th> <td>TURNER</td> <td>1500</td> </tr> <tr> <th>13</th> <td>WARD</td> <td>1250</td> </tr> <tr> <th>14</th> <td>None</td> <td>29025</td> </tr> </tbody> </table> </div> <ul> <li><code>GROUPING SETS</code>는 <strong>지정한 컬럼에 대한 그룹연산 결과만</strong> 출력</li> <li>반면, <code>ROLEUP</code>, <code>CUBE</code>는 <strong>전체 그룹 연산</strong>까지 출력함!</li> </ul> <h3 id="55번">55번</h3> <ul> <li>FK는 여러 개일수 있다는 점! <ul> <li>단순히 PK와 FK가 같은 데이터를 찾으면 FK가 여러개인 경우 해당 데이터들이 모두 출력됨</li> </ul> </li> <li><em>쿼리문 꼼꼼히 끝까지 해석하기!</em></li> </ul> <h3 id="56번">56번</h3> <ul> <li>UNION은 무조건 중복데이터는 1개만 두고 나머지 삭제함!</li> </ul> <h3 id="57번">57번</h3> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span>b.grade,
<span style="color: #bbbbbb">       </span>a.job,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">sum</span>(a.sal)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AS</span><span style="color: #bbbbbb"> </span>sum_sal,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">count</span>(<span style="color: #666666">*</span>)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AS</span><span style="color: #bbbbbb"> </span>cnt
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>emp<span style="color: #bbbbbb"> </span>a,
<span style="color: #bbbbbb">     </span>salgrade<span style="color: #bbbbbb"> </span>b
<span style="color: #008000; font-weight: bold">WHERE</span><span style="color: #bbbbbb"> </span>a.sal<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BETWEEN</span><span style="color: #bbbbbb"> </span>b.losal<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AND</span><span style="color: #bbbbbb"> </span>b.hisal
<span style="color: #008000; font-weight: bold">GROUP</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">GROUPING</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sets</span>(grade,<span style="color: #bbbbbb"> </span>(job,<span style="color: #bbbbbb"> </span>grade))
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>GRADE</th> <th>JOB</th> <th>SUM_SAL</th> <th>CNT</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>1</td> <td>CLERK</td> <td>2850</td> <td>3</td> </tr> <tr> <th>1</th> <td>2</td> <td>SALESMAN</td> <td>2500</td> <td>2</td> </tr> <tr> <th>2</th> <td>2</td> <td>CLERK</td> <td>1300</td> <td>1</td> </tr> <tr> <th>3</th> <td>3</td> <td>SALESMAN</td> <td>3100</td> <td>2</td> </tr> <tr> <th>4</th> <td>4</td> <td>MANAGER</td> <td>8275</td> <td>3</td> </tr> <tr> <th>5</th> <td>4</td> <td>ANALYST</td> <td>6000</td> <td>2</td> </tr> <tr> <th>6</th> <td>5</td> <td>PRESIDENT</td> <td>5000</td> <td>1</td> </tr> <tr> <th>7</th> <td>1</td> <td>None</td> <td>2850</td> <td>3</td> </tr> <tr> <th>8</th> <td>2</td> <td>None</td> <td>3800</td> <td>3</td> </tr> <tr> <th>9</th> <td>3</td> <td>None</td> <td>3100</td> <td>2</td> </tr> <tr> <th>10</th> <td>4</td> <td>None</td> <td>14275</td> <td>5</td> </tr> <tr> <th>11</th> <td>5</td> <td>None</td> <td>5000</td> <td>1</td> </tr> </tbody> </table> </div> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span>b.grade,
<span style="color: #bbbbbb">       </span>a.job,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">sum</span>(a.sal)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AS</span><span style="color: #bbbbbb"> </span>sum_sal,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">count</span>(<span style="color: #666666">*</span>)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AS</span><span style="color: #bbbbbb"> </span>cnt
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>emp<span style="color: #bbbbbb"> </span>a,
<span style="color: #bbbbbb">     </span>salgrade<span style="color: #bbbbbb"> </span>b
<span style="color: #008000; font-weight: bold">WHERE</span><span style="color: #bbbbbb"> </span>a.sal<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BETWEEN</span><span style="color: #bbbbbb"> </span>b.losal<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AND</span><span style="color: #bbbbbb"> </span>b.hisal
<span style="color: #008000; font-weight: bold">GROUP</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">ROLLUP</span><span style="color: #bbbbbb"> </span>(grade,
<span style="color: #bbbbbb">                 </span>job)
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>GRADE</th> <th>JOB</th> <th>SUM_SAL</th> <th>CNT</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>1.0</td> <td>CLERK</td> <td>2850</td> <td>3</td> </tr> <tr> <th>1</th> <td>2.0</td> <td>SALESMAN</td> <td>2500</td> <td>2</td> </tr> <tr> <th>2</th> <td>2.0</td> <td>CLERK</td> <td>1300</td> <td>1</td> </tr> <tr> <th>3</th> <td>3.0</td> <td>SALESMAN</td> <td>3100</td> <td>2</td> </tr> <tr> <th>4</th> <td>4.0</td> <td>MANAGER</td> <td>8275</td> <td>3</td> </tr> <tr> <th>5</th> <td>4.0</td> <td>ANALYST</td> <td>6000</td> <td>2</td> </tr> <tr> <th>6</th> <td>5.0</td> <td>PRESIDENT</td> <td>5000</td> <td>1</td> </tr> <tr> <th>7</th> <td>1.0</td> <td>None</td> <td>2850</td> <td>3</td> </tr> <tr> <th>8</th> <td>2.0</td> <td>None</td> <td>3800</td> <td>3</td> </tr> <tr> <th>9</th> <td>3.0</td> <td>None</td> <td>3100</td> <td>2</td> </tr> <tr> <th>10</th> <td>4.0</td> <td>None</td> <td>14275</td> <td>5</td> </tr> <tr> <th>11</th> <td>5.0</td> <td>None</td> <td>5000</td> <td>1</td> </tr> <tr> <th>12</th> <td>NaN</td> <td>None</td> <td>29025</td> <td>14</td> </tr> </tbody> </table> </div> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span>b.grade,
<span style="color: #bbbbbb">       </span>a.job,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">sum</span>(a.sal)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AS</span><span style="color: #bbbbbb"> </span>sum_sal,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">count</span>(<span style="color: #666666">*</span>)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AS</span><span style="color: #bbbbbb"> </span>cnt
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>emp<span style="color: #bbbbbb"> </span>a,
<span style="color: #bbbbbb">     </span>salgrade<span style="color: #bbbbbb"> </span>b
<span style="color: #008000; font-weight: bold">WHERE</span><span style="color: #bbbbbb"> </span>a.sal<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BETWEEN</span><span style="color: #bbbbbb"> </span>b.losal<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AND</span><span style="color: #bbbbbb"> </span>b.hisal
<span style="color: #008000; font-weight: bold">GROUP</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span>grade,
<span style="color: #bbbbbb">         </span><span style="color: #008000; font-weight: bold">ROLLUP</span><span style="color: #bbbbbb"> </span>(job)
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>GRADE</th> <th>JOB</th> <th>SUM_SAL</th> <th>CNT</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>1</td> <td>CLERK</td> <td>2850</td> <td>3</td> </tr> <tr> <th>1</th> <td>2</td> <td>SALESMAN</td> <td>2500</td> <td>2</td> </tr> <tr> <th>2</th> <td>2</td> <td>CLERK</td> <td>1300</td> <td>1</td> </tr> <tr> <th>3</th> <td>3</td> <td>SALESMAN</td> <td>3100</td> <td>2</td> </tr> <tr> <th>4</th> <td>4</td> <td>MANAGER</td> <td>8275</td> <td>3</td> </tr> <tr> <th>5</th> <td>4</td> <td>ANALYST</td> <td>6000</td> <td>2</td> </tr> <tr> <th>6</th> <td>5</td> <td>PRESIDENT</td> <td>5000</td> <td>1</td> </tr> <tr> <th>7</th> <td>1</td> <td>None</td> <td>2850</td> <td>3</td> </tr> <tr> <th>8</th> <td>2</td> <td>None</td> <td>3800</td> <td>3</td> </tr> <tr> <th>9</th> <td>3</td> <td>None</td> <td>3100</td> <td>2</td> </tr> <tr> <th>10</th> <td>4</td> <td>None</td> <td>14275</td> <td>5</td> </tr> <tr> <th>11</th> <td>5</td> <td>None</td> <td>5000</td> <td>1</td> </tr> </tbody> </table> </div> <div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">SELECT</span><span style="color: #bbbbbb"> </span>b.grade,
<span style="color: #bbbbbb">       </span>a.job,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">sum</span>(a.sal)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AS</span><span style="color: #bbbbbb"> </span>sum_sal,
<span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">count</span>(<span style="color: #666666">*</span>)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AS</span><span style="color: #bbbbbb"> </span>cnt
<span style="color: #008000; font-weight: bold">FROM</span><span style="color: #bbbbbb"> </span>emp<span style="color: #bbbbbb"> </span>a,
<span style="color: #bbbbbb">     </span>salgrade<span style="color: #bbbbbb"> </span>b
<span style="color: #008000; font-weight: bold">WHERE</span><span style="color: #bbbbbb"> </span>a.sal<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BETWEEN</span><span style="color: #bbbbbb"> </span>b.losal<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">AND</span><span style="color: #bbbbbb"> </span>b.hisal
<span style="color: #008000; font-weight: bold">GROUP</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">BY</span><span style="color: #bbbbbb"> </span>grade,
<span style="color: #bbbbbb">         </span><span style="color: #008000; font-weight: bold">CUBE</span><span style="color: #bbbbbb"> </span>(job)
</pre></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>GRADE</th> <th>JOB</th> <th>SUM_SAL</th> <th>CNT</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>1</td> <td>None</td> <td>2850</td> <td>3</td> </tr> <tr> <th>1</th> <td>1</td> <td>CLERK</td> <td>2850</td> <td>3</td> </tr> <tr> <th>2</th> <td>2</td> <td>None</td> <td>3800</td> <td>3</td> </tr> <tr> <th>3</th> <td>2</td> <td>CLERK</td> <td>1300</td> <td>1</td> </tr> <tr> <th>4</th> <td>2</td> <td>SALESMAN</td> <td>2500</td> <td>2</td> </tr> <tr> <th>5</th> <td>3</td> <td>None</td> <td>3100</td> <td>2</td> </tr> <tr> <th>6</th> <td>3</td> <td>SALESMAN</td> <td>3100</td> <td>2</td> </tr> <tr> <th>7</th> <td>4</td> <td>None</td> <td>14275</td> <td>5</td> </tr> <tr> <th>8</th> <td>4</td> <td>ANALYST</td> <td>6000</td> <td>2</td> </tr> <tr> <th>9</th> <td>4</td> <td>MANAGER</td> <td>8275</td> <td>3</td> </tr> <tr> <th>10</th> <td>5</td> <td>None</td> <td>5000</td> <td>1</td> </tr> <tr> <th>11</th> <td>5</td> <td>PRESIDENT</td> <td>5000</td> <td>1</td> </tr> </tbody> </table> </div> <ul> <li>ROLLUP 에 전달한 컬럼이 2개면 해당 컬럼들의 총합이 출력됨</li> </ul> <h3 id="58번">58번</h3> <h4 id="window-function-윈도우함수">WINDOW FUNCTION 윈도우함수</h4> <pre><code class="language-sql">SELECT 윈도우함수(대상) OVER([PARTITION BY 컬럼]
[ORDER BY 컬럼 ASC|DESC]
[ROWS|RANGE BETWEEN A AND B]);
</code></pre> <ul> <li>OVER 절을 활용해서 그룹함수를 윈도우함수로 활용</li> <li>PARTITION BY : 연산결과만 출력하는 / 그룹연산 수행할 GROUP BY 컬럼</li> </ul> <h4 id="ratio_to_report">RATIO_TO_REPORT()</h4> <ul> <li>비율을 계산</li> </ul> <h3 id="60번">60번</h3> <h4 id="계층형-질의">계층형 질의</h4> <ul> <li>하나의 테이블 내 각 행끼리의 관계를 가질때, 연결고리로 행-행 사이의 계층을 표현</li> <li>PRIOR 위치에 따라 연결 데이터가 달라짐 <pre><code class="language-sql">  SELECT
  FROM 테이블 명
  START WITH 시작조건
  CONNECT BY PRIOR 연결조건;
</code></pre> </li> <li>START WITH : 데이터 출력할 시작 지정하는 조건 <ul> <li>해당 데이터가 있는 행이 LEVEL 1</li> </ul> </li> <li>CONNECT BY PRIOR : 시작점을 기준으로 하위 레벨을 찾아가는 조건 <ul> <li>행을 이어나갈 조건</li> </ul> </li> <li>ORDER SIBLINGS BY 컬럼 : 같은 LEVEL 일 경우 정렬 수행</li> </ul> <p><br/></p> <ul> <li>DESC : 내림차순 <ul> <li>큰 → 작은</li> </ul> </li> </ul>]]></content><author><name></name></author><category term="study"/><category term="자격증"/><category term="sqld"/><category term="skill-stacking"/><summary type="html"><![CDATA[SQLD 5주차 공부 기록]]></summary></entry><entry><title type="html">SQLD 공부 실전문제 오답노트 - PART 2 - CH1. SQL 기본</title><link href="https://seulwithlove.github.io/blog/2024/get-sqld-exercise-1/" rel="alternate" type="text/html" title="SQLD 공부 실전문제 오답노트 - PART 2 - CH1. SQL 기본"/><published>2024-05-19T00:00:00+00:00</published><updated>2024-05-19T00:00:00+00:00</updated><id>https://seulwithlove.github.io/blog/2024/get-sqld-exercise-1</id><content type="html" xml:base="https://seulwithlove.github.io/blog/2024/get-sqld-exercise-1/"><![CDATA[<h2 id="sqld---week-4---실전문제-part2---1-sql-기본">SQLD - Week 4 - 실전문제 Part2 - 1. SQL 기본</h2> <ul> <li>&lt;<a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=332583104">SQL 자격검정 실전문제</a>&gt; (일명 노랭이) 개정판 1회독 + 오답노트 <ul> <li>출제 비중이 높은 Part 2 부터 시작</li> </ul> </li> <li>오답노트하며 중요한 개념 정리</li> </ul> <h3 id="11번">11번</h3> <ul> <li>SQL Server는 <code>''</code> 빈 문자열과 NULL을 구분함</li> <li>문자열은 <code>' '</code> 홑따옴표를 사용 <ul> <li><code>" "</code> 쌍따옴표는 식별자(테이블명, 컬럼명) 지정에서 사용 <ul> <li>쌍따옴표 내부에 있는 문자는 대소문자 구분</li> </ul> </li> </ul> </li> <li>숫자는 따옴표 없이 그냥 적음</li> </ul> <h3 id="13번">13번</h3> <ul> <li>TO_CHAR(SVC_END_DATE, ‘YYYYMM’) 과 TO_DATE(‘201501’, ‘YYYYMM’)은 다름!</li> </ul> <h3 id="15번">15번</h3> <ul> <li><code>LENGTH()</code> : 문자열의 개수를 숫자값으로 리턴</li> <li><code>CHR(ASCII번호)</code> : 아스키 코드 번호를 문자나 숫자로 바꿈 <ul> <li>줄바꿈은 길이 1 (LENGTH(CHR(10)) = 1)</li> </ul> </li> <li><code>REPLACE(문자열, 찾을문자열, 치환문자열)</code> : 치환문자열을 생략하거나 빈문자열 전달 -&gt; 찾을문자열 <strong>삭제</strong>!</li> </ul> <h3 id="16번">16번</h3> <ul> <li><code>+1/24/(60/10)</code> : 연산식!</li> <li>oracle에서 날짜나 시간에 숫자연산이 가능함 -&gt; 날짜 연산은 숫자 연산과 같음 <ul> <li>특정날짜 + 1 = “하루”를 더하는 의미 <blockquote> <ul> <li>1/24 : 하루를 24시간으로 나눈다 = 60분</li> <li>60/(60/10) : 60분을 6으로 나눈다 = 10분</li> </ul> </blockquote> </li> </ul> </li> </ul> <h3 id="24번">24번</h3> <ul> <li>oracle에서는 DATE_FORMAT 명령어 사용 안되는듯!</li> <li><strong>TO_CHAR</strong> / <strong>TO_DATE</strong> 활용</li> </ul> <h3 id="27번">27번</h3> <ul> <li>GROUP BY 컬럼을 중심으로 집계함수/ 그룹함수의 연산을 진행</li> </ul> <h3 id="29번">29번</h3> <ul> <li><code>ORDER BY COUNT(*) ASC</code> : 그룹핑된 행의 개수를 세서 그 수의 오름차순으로 정렬</li> <li>GROUP BY가 있는 경우 ORDER BY 에서도 그룹함수를 이용해야함</li> </ul> <h3 id="30번---오라클-시간계산">30번 - 오라클 시간계산</h3> <ul> <li><code>1/24</code> : 1시간 = 60분 (1일 / 24시간)</li> <li><code>1/24/60</code> : 1분 (1일 / 24시간 = 1시간 / 60 = 1분)</li> <li><code>1/24/6</code> : 10분</li> <li><code>1/24/60/6</code> : 10초</li> <li><code>1/12/(60/30)</code> : 1시간</li> <li><code>1.5/24</code> : 1시간 30분</li> <li><code>1.5/24/6</code> : 15분 <ul> <li>각 단위끼리 계산하기 어려우면 단위를 맞춰 변환후 계산 <ul> <li>e.g. 1일 / 24시간 = 24시간 / 24시간 = 1시간</li> <li>e.g. 1일 / 12시간 = 24시간 / 12시간 = 2시간</li> <li>e.g. 1일 / 24시간 / 6분 = 1시간 / 6분 = 60분 / 6분 = 10분</li> </ul> </li> </ul> </li> <li>참고: <a href="https://gent.tistory.com/244">블로그</a>, <a href="https://nocount.tistory.com/53">오류노트:티스토리</a></li> </ul> <h3 id="31번">31번</h3> <ul> <li><code>NULLIF(표현식1, 표현식2)</code> : 표현식1 = 표현식2 이면 NULL, 다르면 ‘1’ 리턴</li> </ul> <h3 id="38번">38번</h3> <ul> <li>JOIN</li> <li>Primary Key PK / Foreign Key FK : 일대다 관계</li> </ul> <h4 id="primary-keypk-기본키">PRIMARY KEY(PK) 기본키</h4> <ul> <li>유일한 식별자(각 행을 구별할수 있는 식별자 기능) <ul> <li><strong>UNIQUE + NOT NULL</strong></li> </ul> </li> <li>테이블 1개 - PK 1개 - 컬럼 여러개</li> </ul> <h4 id="foreign-key">FOREIGN KEY</h4> <ul> <li>자식테이블에 거는 장치</li> <li>부모 테이블을 참조하면서 관리</li> </ul> <h3 id="45번">45번</h3> <h4 id="union--union-all-구분">UNION / UNION ALL 구분</h4> <ul> <li>UNION : 중복된 데이터는 한 번만 출력 <ul> <li>중복된 데이터 제거, 자체 정렬</li> </ul> </li> <li>UNION ALL : 중복된 데이터 전체 출력</li> <li>JOIN 과의 차이점 <ul> <li>JOIN : 새로운 열로 결합(수평 결합)</li> <li>UNION : 새로운 행으로 결합(수직 결합)</li> <li>참고 : <a href="https://silverji.tistory.com/49">블로그</a></li> </ul> </li> </ul> <h4 id="full-outer-join">FULL OUTER JOIN</h4> <ul> <li>두 테이블 전체 기준으로 결과를 생성 → <strong>중복 데이터는 하나만 남기고 삭제</strong> 후 리턴</li> <li><code>'LEFT OUTER JOIN 결과' UNION 'RIGHT OUTER JOIN 결과'</code>와 동일 <ul> <li>ORACLE 표준에는 없음 <pre><code class="language-sql">SELECT column_name(s)
FROM table1
FULL OUTER JOIN table2
ON table1.column_name = table2.column_name
WHERE condition;
</code></pre> </li> </ul> </li> <li><em>Q:”그럼 FULL OUTER JOIN의 경우 ON 절의 조건은 상관없는건가..?”</em></li> </ul> <h3 id="49번">49번</h3> <h4 id="oracle-표준-outer-join">ORACLE 표준 ‘OUTER JOIN’</h4> <ul> <li>WHERE 절에서 기준이 되는 테이블 반대 테이블 조건 컬럼 뒤에 (+)를 붙임</li> <li>Inner 테이블 조건은 ON절에 포함시켜야 함</li> </ul> <h3 id="50번">50번</h3> <ul> <li>컬럼끼리 연산에서 NULL 있으면 NULL</li> <li>레코드끼리 연산에서 NULL 있으면 무시하고 연산 <ul> <li>e.g. SUM(COL1 + COL2) <ul> <li>각 컬럼의 행별 연산을 하고난 뒤에 각 행 연산결과를 모두 합함</li> <li>첫 행의 데이터가 ‘NULL + 10’ 이면 =&gt; NULL</li> <li>두번째 행의 데이터가 ‘10 + 20’ 이면 =&gt; 30</li> <li>SUM 연산하면 =&gt; 30</li> </ul> </li> </ul> </li> </ul> <h4 id="important">IMPORTANT!</h4> <ul> <li>문제를 읽고 작업내용 정리 <ul> <li>문제가 줄글로 되어있는 경우 어떤 작업을 해야하는지 빨리 찾아내는게 중요</li> <li>SELECT절에 사용할 내용, FROM절, .. 각 절에서 필요한 정보를 구분해서 표시하자!</li> </ul> </li> </ul>]]></content><author><name></name></author><category term="study"/><category term="자격증"/><category term="sqld"/><category term="skill-stacking"/><summary type="html"><![CDATA[SQLD 4주차 공부 기록]]></summary></entry><entry><title type="html">SQLD 공부 PART 2 - CH3. 관리구문</title><link href="https://seulwithlove.github.io/blog/2024/get-sqld-part2-3/" rel="alternate" type="text/html" title="SQLD 공부 PART 2 - CH3. 관리구문"/><published>2024-05-17T00:00:00+00:00</published><updated>2024-05-17T00:00:00+00:00</updated><id>https://seulwithlove.github.io/blog/2024/get-sqld-part2-3</id><content type="html" xml:base="https://seulwithlove.github.io/blog/2024/get-sqld-part2-3/"><![CDATA[<h2 id="sqld---week-4---part2---ch3-관리구문">SQLD - Week 4 - Part2 - CH3. 관리구문</h2> <ul> <li>유튜브 &lt;<a href="https://www.youtube.com/@hdatalab">홍쌤의 데이터랩</a>&gt;, 강의자료 단권화</li> <li>책 &lt;2023 유선배 SQL개발자(SQLD) 과외노트&gt; 참고</li> <li>참고 : <a href="https://seung-story.tistory.com/140">블로그 Seung_story</a></li> </ul> <h3 id="1-dml-data-manipulation-language">1. DML (Data Manipulation Language)</h3> <ul> <li>데이터 수정어</li> <li>반드시 commit(저장), rollback(취소)으로 transaction 제어해야함!! <br/></li> </ul> <h4 id="insert">INSERT</h4> <ul> <li>한 번에 한 행만 입력 <ul> <li>여러 행 한꺼번에 입력하려면 서브쿼리 활용</li> <li>e.g. <code>INSERT INTO EMP3(EMPNO, ENAME, DEPTNO)</code></li> </ul> </li> <li><strong>컬럼별 데이터타입, 사이즈</strong> 맞게 삽입!!</li> </ul> <pre><code class="language-sql">INSERT INTO 테이블 VALUES(value1, value2, ...);
INSERT INTO 테이블(컬럼1, 컬럼2, ...) VALUES(value1, value2, ...);
</code></pre> <ul> <li>INTO 절의 테이블에 컬럼명 명시안하면 전체 컬럼에 데이터 입력하겠다는 의미 <ul> <li>컬럼수에 맞는 value값 전달!</li> </ul> </li> <li>INTO 절에 컬럼명 명시해서 일부 컬럼만 입력 가능 <ul> <li>작성하지 않은 컬럼은 NULL 입력됨 <ul> <li>해당 컬럼이 NOT NULL 속성인 경우 에러발생! 유의!</li> </ul> </li> </ul> </li> <li>문자 컬럼에 숫자값 입력 가능(권장X)</li> <li>숫자 컬럼에 문자값 입력 가능(권장X)</li> </ul> <h4 id="update">UPDATE</h4> <ul> <li>단일 컬럼 수정 <pre><code class="language-sql">UPDATE 테이블명
SET 수정할컬럼명 = 수정값
WHERE 조건;
</code></pre> </li> <li>다중 컬럼 수정 (서브쿼리 사용) <pre><code class="language-sql">UPDATE 테이블명
SET (수정할컬럼명1, 수정할컬럼명2, ...) = (SELECT 수정값1, 수정값2, ...)
WHERE 조건;
</code></pre> </li> </ul> <h4 id="delete">DELETE</h4> <pre><code class="language-sql">DELETE [FROM] 테이블명
[WHERE 조건];
</code></pre> <ul> <li>FROM 생략 가능</li> <li>WHERE 조건 전달안할경우 모든 행 삭제 됨</li> </ul> <h4 id="merge">MERGE</h4> <ul> <li>병합 : 참조 테이블 필수 <pre><code class="language-sql">MERGE INTO 테이블명
USING 참조테이블
ON (연결조건)
WHEN MATCHED THEN
   UPDATE
      SET 수정할내용
WHEN NOT MATCHED THEN
   INSERT VALUES(삽입할내용)
</code></pre> </li> </ul> <h3 id="2-tcl-transaction-control-language">2. TCL (Transaction Control Language)</h3> <ul> <li>트랜잭션 제어어</li> <li>DML(UPDATE, INSERT, DELETE)에서 많이 사용 <ul> <li>DDL은 AUTO COMMIT</li> </ul> </li> <li>특성 <ul> <li>원자성(atomicity) : 트랜잭션 정의된 연산들 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태로 남아 있어야 함</li> <li>일관성(consistency) : 트랜잭션 실행 전 데이터베이스 내용이 잘못되어 있지 않다면 트랜잭션 실행 이후에도 데이터베이스 내용의 잘못이 있으면 안됨</li> <li>고립성(isolation) : 트랜잭션 실행도중 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안됨 <ul> <li>LOCKING 으로 고립성 보장 <ul> <li>트랜잭션이 수행하는 동안 특정 데이터에 대해 다른 트랜잭션이 동시에 접근하지 못하게 제한</li> </ul> </li> </ul> </li> <li>지속성(durability) : 트랜잭션이 성공적으로 수행되면 갱신한 데이터베이스 내용이 영구적으로 저장</li> </ul> </li> </ul> <h4 id="commit">COMMIT</h4> <ul> <li>데이터 저장 : 데이터베이스 변경시 올바르게 반영된 데이터를 데이터베이스에 반영</li> <li>COMMIT 하고 나면 되돌릴수 없음</li> <li>DDL하면 AUTO COMMIT : 되돌릴수 없음(23c 버전부터 비활성화 가능)</li> </ul> <h4 id="rollback">ROLLBACK</h4> <ul> <li>데이터 원복 : 트랜잭션 시작 이전 상태로 돌림</li> <li>시점이 매우 중요! : 최종 COMMIT 시점/변경 전/특정 SAVEPOINT 시점</li> </ul> <h4 id="savepoint">SAVEPOINT</h4> <ul> <li>트랜잭션 시점</li> <li>책갈피처럼 끼워두는 곳(COMMIT전) <ul> <li>원하는 이름으로 설정 가능</li> </ul> </li> </ul> <h3 id="3-ddl-data-definition-language">3. DDL (Data Definition Language)</h3> <ul> <li>데이터 구조 정의어(객체 생성, 삭제, 변경)</li> <li>AUTO COMMIT 특성 : 명령어 수행하면 즉시 저장/원복 불가</li> </ul> <h4 id="create">CREATE</h4> <ul> <li>객체 생성(테이블/인덱스)</li> <li>명령어 전달 순서대로 생성</li> <li>테이블 생성시 소유자 명시 가능</li> </ul> <h5 id="데이터-타입">데이터 타입</h5> <ul> <li>CHAR(n) : 고정형 문자 <ul> <li>사이즈</li> </ul> </li> <li>VARCHAR2(n)</li> <li>NUMBER(p,s)</li> <li>DATE</li> <li>참고 : 묵시적 형변환을 하기도 함(데이터 타입을 자동으로 변환) <ul> <li>VARCHAR2 → NUMBER</li> <li>VARCHAR2 → DATE</li> <li>NUMBER → VARCHAR2</li> <li>DATE → VARCHAR2</li> </ul> </li> </ul> <h4 id="alter">ALTER</h4> <ul> <li>테이블 구조 변경</li> </ul> <h5 id="1-add-컬럼추가">1. ADD 컬럼추가</h5> <pre><code class="language-sql">ALTER TABLE 테이블명 ADD 컬럼명 데이터타입 [DEFAULT] [제약조건];
</code></pre> <ul> <li>기존에 데이터가 있는 테이블에 컬럼 추가시 NOT NULL 속성 전달 불가! <ul> <li>컬럼 추가하면 자동으로 NULL로 채워짐</li> <li>데이터 없는 테이블에는 NOT NULL 속성 컬럼 추가 O</li> <li>데이터 전달하면 가능 <code>... DEFAULT value NOT NULL;</code></li> </ul> </li> <li>여러 컬럼 동시 추가 가능 : 반드시 괄호 사용 <ul> <li>SQL Server는 여러 컬럼 동시 수정X (괄호 사용X)</li> </ul> </li> </ul> <h5 id="2-modify-변경">2. MODIFY 변경</h5> <ul> <li>여러 컬럼 동시 변경 가능 <br/></li> <li>컬럼 사이즈</li> <li>데이터타입 <ul> <li>빈 컬럼인 경우 데이터 타입 변경 가능</li> </ul> </li> <li>DEFAULT 값 변경 <ul> <li>DEFAULT 값은 특정 컬럼에 값이 생략될 경우 자동으로 부여되는 값</li> <li>NULL로 채우고 싶은 경우 DEFAULT 대신 NULL 입력</li> <li>기존에 있는 데이터에는 영향X -&gt; 새로 입력되는 데이터부터 영향</li> </ul> </li> </ul> <h5 id="3-rename--컬럼명-변경">3. RENAME : 컬럼명 변경</h5> <h5 id="4-drop-column--컬럼-삭제">4. DROP COLUMN : 컬럼 삭제</h5> <ul> <li><code>ALTER TABLE table_name DROP COLUMN column_name;</code></li> </ul> <p><strong>[DELETE - DROP - TRUNCATE]</strong></p> <ul> <li>DELETE : 데이터 일부 / 전체 삭제 - 롤백 가능</li> <li>DROP : 객체(테이블, 인덱스) 즉시 삭제 - 롤백 불가(AUTO COMMIT) <ul> <li>실행 이후 조회 불가</li> <li>해당 스키마 뿐 아니라 연관 객체도 모두 삭제하려면 ‘CASCADE’ - e.g. <code>DROP SCHEMA EMPLOYEE CASCADE;</code></li> </ul> </li> <li>TRUNCATE : 구조 남기고 데이터만 즉시 삭제 - 롤백 불가(AUTO COMMIT)</li> </ul> <h4 id="제약조건">제약조건</h4> <ul> <li>데이터 무결성을 위해 각 컬럼에 생성하는 데이터 제약 장치</li> <li>UNIQUE : 중복 허용X</li> <li>NULL</li> <li>NOT NULL</li> </ul> <h5 id="primary-keypk-기본키">PRIMARY KEY(PK) 기본키</h5> <ul> <li>유일한 식별자(각 행을 구별할수 있는 식별자 기능)</li> <li><strong>UNIQUE + NOT NULL</strong> <ul> <li>PRIMARY KEY 생성하면 NOT NULL 속성 자동 부여</li> </ul> </li> <li>테이블 1개 - PK 1개 - 컬럼 여러개</li> <li>CREATE TABLE 때 생성 <pre><code class="language-sql">// 방법 1
  CREATE TABLE table_name  
  (  
  column_name1 datatype (size) PRIMARY KEY,  
  column_name2 datatype (size),  
  .  
  .  
  column_nameN datatype(size)  
  );

// 방법 2 - 제약조건 이름 사용
  CREATE TABLE table_name  
  (  
  column_name1 datatype (size),  
  column_name2 datatype (size),  
  .  
  .  
  column_nameN datatype(size),
  CONSTRAINT constraint_name PRIMARY KEY (column_name)  
  );
</code></pre> </li> <li>ALTER TABLE 때 생성 <pre><code class="language-sql">// 방법 1 - 컬럼명 사용
ALTER TABLE table_name
ADD PRIMARY KEY (column_name);

// 방법 2 - 제약조건 이름 사용
ALTER TABLE table_name
ADD CONSTRAINT constraint_name PRIMARY KEY (column_name);
</code></pre> </li> </ul> <h5 id="foreign-key">FOREIGN KEY</h5> <ul> <li>자식테이블에 거는 장치</li> <li>부모 테이블을 참조하면서 관리</li> <li>CREATE TABLE 때 생성 <pre><code class="language-sql">CREATE TABLE 자식테이블명(
  컬럼1 데이터타입 [DEFAULT value] FOREIGN KEY REFERENCES 부모테이블(PK명),
  ...
);
</code></pre> <ul> <li>컬럼1 : 여기에 FOREIGN KEY 거는것!</li> <li><strong>참조키</strong> : 사전에 <strong>PK / UNIQUE KEY</strong> 로 지정되어야함!</li> </ul> </li> <li>ALTER TABLE 때 생성 <pre><code class="language-sql">// 방법 1 - 컬럼명 사용
ALTER TABLE 테이블명
ADD FOREIGN KEY (컬럼명) REFERENCES 부모테이블(PK명);

// 방법 2 - 제약조건 이름 사용
ALTER TABLE 테이블명
ADD CONSTRAINT 제약조건이름 
FOREIGN KEY (컬럼명) REFERENCES 부모테이블(PK명);
</code></pre> </li> <li><strong>자식테이블</strong> : <strong>INSERT, UPDATE 제약</strong> 생김</li> <li><strong>부모테이블</strong> : <strong>UPDATE, DELETE</strong> 제약 생김</li> </ul> <p><strong>[FOREIGN KEY Constraints]</strong></p> <ul> <li><strong>ON DELETE 옵션</strong> <ul> <li>ON DELETE CASCADE : 부모 데이터 삭제 → 자식 데이터 함께 삭제 <ul> <li>테이블 자체가 삭제됨</li> </ul> </li> <li>ON DELETE SET NULL : 부모 데이터 삭제 → 자식 데이터 참조값 NULL로 수정</li> <li>ON DELETE SET DEFAULT : 부모 데이터 삭제 → 자식 데이터 DEFAULT 값으로 설정</li> <li>ON DELETE RESTRICT : 자식 테이블에 PK값이 없는 경우만 부모 데이터 삭제 허용</li> <li>ON NO ACTION : 참조무결성을 위반하는 삭제/수정 액션을 취하지 않음</li> </ul> </li> <li><strong>ON UPDATE / INSERT 옵션</strong> <ul> <li>AUTOMATIC</li> <li>SET NULL</li> <li>SET DEFAULT</li> <li>DEPENDENT</li> <li>NO ACTION <ul> <li>위 옵션은 <SQL 자격검정="" 실전문제=""> 2023년 개정판 문제 해설에 있는 내용</SQL></li> <li>구글링했을때 insert의 옵션 정보는 거의 나오지 않음</li> <li><a href="https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html">mysql</a>에서만 아래의 정보를 제공하고 있음</li> <li>어떤게 맞는 내용인지 확인하지 못함 ```sql [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (col_name, …) REFERENCES tbl_name (col_name,…) [ON DELETE reference_option] [ON UPDATE reference_option]</li> </ul> <p>reference_option: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT ```</p> </li> </ul> </li> </ul> <h4 id="기타-오브젝트--view-뷰">기타 오브젝트 : View 뷰</h4> <pre><code class="language-sql">CREATE [OR REPLACE] VIEW 뷰이름
AS
조회쿼리;
</code></pre> <ul> <li>‘query alias’ 라고도 함</li> <li>뷰를 만들고 select문과 연동시켜두면 뷰로 해당 select문 조회가능</li> <li>특징 <ul> <li>가상의 테이블 : 저장공간을 차지X</li> <li>기본 테이블 삭제 → 해당 테이블 참조해서 만든 뷰도 삭제됨</li> </ul> </li> <li>장점 <ul> <li>독립성 : 테이블 구조가 바뀌어도 뷰 사용하는 응용프로그램은 변경 필요 X</li> <li>편리성 : 복잡한 쿼리를 뷰로 생성 관련 쿼리를 단순하게 작성가능 <ul> <li>데이터 관리 단순화</li> </ul> </li> <li>보안성 : 숨기고 싶은 데이터는 제외하고 뷰를 생성 → 데이터 접근 제어 가능</li> </ul> </li> <li>단점 <ul> <li>수정 불가</li> <li>인덱스 구성 불가</li> </ul> </li> </ul> <h3 id="4-dcl-data-control-language">4. DCL (Data Control Language)</h3> <ul> <li>데이터 제어어 : “권한”으로 통제! <h4 id="권한-종류">권한 종류</h4> </li> <li>오브젝트 권한 : 테이블에 대한 권한(SELECT, INSERT, UPDATE, DELETE, MERGE) <ul> <li>테이블 소유자는 소유 테이블 조회/수정 권한 부여/회수 가능</li> </ul> </li> <li>시스템 권한 : 시스템 작업(테이블 생성, 인덱스 삭제) <ul> <li>관리자 권한만 부여/회수 가능</li> </ul> </li> <li><strong>ROLE</strong> : 권한 묶음 <ul> <li>공통된 속성을 지닌 권한을 묶는 역할</li> <li>권한 관리를 편하게 하기 위해</li> <li>부여후 재접속해야 반영됨(원래 권한은 부여후 바로 실행됨)</li> <li><u>ROLE을 통해 부여한 권한은 직접 회수 X</u> <ul> <li>ROLE을 통한 회수만 가능</li> </ul> </li> </ul> </li> </ul> <h4 id="grant--권한-부여">GRANT : 권한 부여</h4> <p><code>GRANT 권한 ON 테이블명 TO 유저;</code></p> <ul> <li>동시에 여러 권한 부여 가능</li> <li>동시에 여러 유저에게 권한 부여 가능</li> <li>동시에 여러 객체(테이블)에 대한 권한 부여 X <ul> <li>옵션 설정 안하면 기본값은 : <code>WITH GRANT OPTION</code></li> </ul> </li> </ul> <h4 id="revoke--권한-회수">REVOKE : 권한 회수</h4> <p><code>REVOKE 권한 ON 테이블명 FROM 유저;</code></p> <ul> <li>동시에 여러 권한 회수 가능</li> <li>동시에 여러 유저로부터 권한 회수 가능</li> </ul> <p><strong>[권한 부여 옵션 - 중간관리자 권한]</strong></p> <ul> <li><strong>WITH GRANT OPTION</strong> : <u>오브젝트 권한을 다른 사용자에게 부여</u> -&gt; 이 사용자는 <code>중간관리자</code>가 됨 <ul> <li>중간관리자가 부여한 권한은 중간관리자만 회수 가능</li> <li>중간관리자에게 부여된 권한 회수 시 제 3 자에게 부여된 권한도 함께 회수됨</li> </ul> </li> <li><strong>WITH ADMIN OPTION</strong> : <u>시스템 권한/롤 권한을 다른 사용자에게 부여 가능</u> -&gt; 이 사용자는 <code>중간관리자</code>가 됨 <ul> <li>중간관리자를 거치지 않고 직접 회수 O</li> <li>중간관리자 권한 회수 : 제3자에게 부여된 권한 함께 회수 X(남아있음)</li> </ul> </li> </ul> <h3 id="종합">종합</h3> <table> <thead> <tr> <th>명령어 종류</th> <th>명령어</th> <th>설명</th> </tr> </thead> <tbody> <tr> <td>DML<br/>데이터조작어</td> <td>SELECT</td> <td> </td> </tr> <tr> <td>DML<br/>데이터조작어</td> <td>INSERT<br/>UPDATE<br/>DELETE</td> <td>데이터에 변형을 가하는 것</td> </tr> <tr> <td>DDL<br/>데이터정의어</td> <td>CREATE<br/>ALTER<br/>DROP<br/>RENAME</td> <td>데이터 구조를 정의</td> </tr> <tr> <td>DCL<br/>데이터제어어</td> <td>GRANT<br/>REVOKE</td> <td>권한으로 데이터 제어</td> </tr> <tr> <td>TCL<br/>트랜잭션제어어</td> <td>COMMIT<br/>ROLLBACK</td> <td>트랜잭션별로 관리</td> </tr> </tbody> </table>]]></content><author><name></name></author><category term="study"/><category term="자격증"/><category term="sqld"/><category term="skill-stacking"/><summary type="html"><![CDATA[SQLD 4주차 공부 기록]]></summary></entry><entry><title type="html">SQLD 공부 PART 2 - CH2. SQL 활용</title><link href="https://seulwithlove.github.io/blog/2024/get-sqld-part2-2/" rel="alternate" type="text/html" title="SQLD 공부 PART 2 - CH2. SQL 활용"/><published>2024-05-16T00:00:00+00:00</published><updated>2024-05-16T00:00:00+00:00</updated><id>https://seulwithlove.github.io/blog/2024/get-sqld-part2-2</id><content type="html" xml:base="https://seulwithlove.github.io/blog/2024/get-sqld-part2-2/"><![CDATA[<h2 id="sqld---week-4---part2---ch2-sql-활용">SQLD - Week 4 - Part2 - CH2. SQL 활용</h2> <ul> <li>유튜브 &lt;<a href="https://www.youtube.com/@hdatalab">홍쌤의 데이터랩</a>&gt;, 강의자료 단권화</li> <li>책 &lt;2023 유선배 SQL개발자(SQLD) 과외노트&gt; 참고</li> <li>참고 : <a href="https://learn.microsoft.com/en-us/sql/t-sql/functions/grouping-transact-sql?view=sql-server-ver16">Microsoft Learn</a>, <a href="https://superkong1.tistory.com/42">블로그 superkong1</a>, <a href="https://n-o-t-e.tistory.com/42">블로그 ooo</a></li> </ul> <h3 id="1-subquery-서브쿼리">1. Subquery 서브쿼리</h3> <ul> <li>하나의 SQL 문 안에 포함되어있는 또다른 SQL문</li> <li>꼭 ( ) 괄호로 묶어야 함!</li> <li>GROUP BY 절은 사용 X</li> </ul> <h4 id="종류">종류</h4> <p><strong>1. 동작하는 방식에 따라</strong></p> <ul> <li>비연관(UN-CORRELATED) 서브쿼리 <ul> <li>서브쿼리가 메인쿼리 컬럼을 가지고 있지 않은 형태</li> <li>메인쿼리에 값을 제공하기 위해 사용</li> </ul> </li> <li>연관(CORRELATED) 서브쿼리 <ul> <li>서브쿼리가 메인쿼리 컬럼을 갖고 있는 형태</li> <li>메인쿼리가 먼저 수행된 후에 서브쿼리에서 조건이 맞는지 확인하려고 할떄 사용</li> </ul> </li> </ul> <p><strong>2. 위치에 따라</strong></p> <ul> <li>스칼라 서브쿼리 : SELECT 절에 사용 <ul> <li>서브쿼리 결과를 <u>'하나의 컬럼'</u>처럼 사용 <ul> <li>1 row 1 column</li> </ul> </li> <li>단일행 서브쿼리! : 2건 이상의 결과 리턴하면 에러</li> </ul> </li> <li><strong>인라인뷰</strong> : <strong>FROM 절</strong>에서 사용 <ul> <li>서브쿼리 결과를 <u>'테이블'</u>처럼 사용</li> <li>SQL문이 실행될때만 임시로 생성되는 뷰라서 ‘동적 뷰 Dynamic View’라고도 함</li> </ul> </li> <li>WHERE 절 서브쿼리 : 가장 일반적인 사용 <ul> <li>비교 상수 자리에 ‘값을 전달’하기 위한 목적(상수항 대체)</li> </ul> </li> </ul> <h4 id="where-절-서브쿼리-종류">WHERE 절 서브쿼리 종류</h4> <p><strong>1) 단일행 서브쿼리</strong></p> <ul> <li>서브쿼리 결과로 1행이 리턴</li> <li>단일행 서브쿼리 연산자 종류 <ul> <li><code>=</code>,<code>&lt;&gt;</code>,<code>&gt;</code>,<code>&lt;</code>,<code>&lt;=</code>,<code>&gt;=</code></li> </ul> </li> </ul> <p><strong>2) 다중행 서브쿼리</strong></p> <ul> <li>서브쿼리 결과로 여러행 리턴</li> <li>비교 연산자 사용 불가(여러 값이랑 비교할수 없는 연산자들) <ul> <li><code>=</code>, <code>&gt;</code>,<code>&lt;</code></li> </ul> </li> <li>다중행 서브쿼리 연산자</li> </ul> <table> <thead> <tr> <th>연산자</th> <th>의 미</th> </tr> </thead> <tbody> <tr> <td>IN</td> <td>같은 값을 찾음</td> </tr> <tr> <td>&gt; ANY</td> <td>최소값 반환</td> </tr> <tr> <td>&lt; ANY</td> <td>최대값 반환</td> </tr> <tr> <td>&lt; ALL</td> <td>최소값 반환</td> </tr> <tr> <td>&gt; ALL</td> <td>최대값 반환</td> </tr> </tbody> </table> <ul> <li>다중행 서브쿼리 연산자는 단일행 서브쿼리 연산자로 사용 가능</li> </ul> <p>예제) ALL 과 ANY 비교</p> <ul> <li>&gt; ANY(2000, 3000) : 최소값(2000)보다 큰 행들 반환</li> <li>&lt; ANY(2000, 3000) : 최대값(3000)보다 작은 행들 반환</li> <li>&gt; ALL(2000, 3000) : 최대값(3000)보다 큰 행들 반환</li> <li>&lt; ALL(2000, 3000) : 최소값(2000)보다 작은 행들 반환</li> </ul> <p><strong>3) 다중컬럼 서브쿼리</strong></p> <ul> <li>서브쿼리 결과로 여러 컬럼 리턴 <ul> <li>메인 쿼리와의 비교 컬럼이 2개 이상</li> </ul> </li> <li>대소 비교 전달 불가(두 값을 동시에 묶어서 대소비교 불가) <ul> <li><code>IN</code> 만 사용가능</li> </ul> </li> <li>SQL Server 사용X</li> </ul> <h3 id="2-집합-연산자">2. 집합 연산자</h3> <ul> <li>두 집합의 컬럼이 동일하게 구성되어야함 <ul> <li>각 컬럼의 데이터 타입</li> <li>컬럼 순서</li> <li>컬럼 수</li> </ul> </li> <li>컬럼 사이즈는 달라도 됨</li> </ul> <h4 id="union--union-all--합집합">UNION / UNION ALL : 합집합</h4> <ul> <li>UNION : 중복된 데이터 제거, <strong>자체 정렬</strong> <ul> <li>중복된 데이터 없으면 UNION ALL 사용! : 불필요한 정렬하므로</li> </ul> </li> <li>UNION ALL : 중복된 데이터도 전체 출력</li> </ul> <h4 id="intersect--교집합">INTERSECT : 교집합</h4> <ul> <li>공통으로 있는 행 출력</li> </ul> <h4 id="minus--차집합">MINUS : 차집합</h4> <ul> <li>순서 중요함!</li> </ul> <h3 id="3-그룹-함수">3. 그룹 함수</h3> <ul> <li>반드시 한 컬럼만 전달</li> <li>컬럼값이 NULL인 Row 제외(무시)</li> <li>GROUP BY 절에 의해 그룹별 연산 결과 리턴 <br/></li> <li>COUNT : 행의 수 출력</li> <li>SUM : 행의 총 합 출력</li> <li>AVG : 평균 <ul> <li>숫자 컬럼만 전달 가능</li> <li>NULL 제외한 대상의 평균을 리턴</li> </ul> </li> <li>MIN / MAX : 최소, 최대 출력 <ul> <li>날짜, 숫자, 문자 모두 가능(오름차순 순서대로)</li> </ul> </li> <li>VARIANCE / STDDEV : 분산, 표준편차</li> </ul> <h3 id="group-by-function">GROUP BY FUNCTION</h3> <ul> <li>여러 GROUP BY 결과를 동시에 출력(합집합)</li> </ul> <h4 id="grouping-setsa-b-">GROUPING SETS(A, B, …)</h4> <ul> <li>A, B별 그룹 연산 결과 출력 <ul> <li>GROUPING SETS에 나열한 대상에 대해 각 GROUP BY 결과를 출력</li> </ul> </li> <li>나열 순서 중요하지X</li> <li><strong>전체 총계는 출력X</strong> <ul> <li>전체 총계 출력하려면 : NULL 혹은 <code>()</code> 사용</li> </ul> </li> <li>’= UNION ALL’ : 빈 컬럼 NULL로 맞춰줘야함</li> <li>GROUPING SETS ((A, B)) = GROUP BY A, B <ul> <li>괄호를 두개 사용하면 A, B를 그룹으로 만들어서 그룹 소계를 집계</li> </ul> </li> </ul> <h4 id="rollupa-b">ROLLUP(A, B)</h4> <ul> <li>주어진 컬럼명 나열순을 기준으로 레벨별 집계를 반환 <ul> <li>(A, B)별, A별(B는 NULL로 집계), 전체 그룹 연산 결과 출력</li> </ul> </li> <li>나열 대상의 <strong>순서</strong> 중요! <ul> <li>나열된 컬럼의 계층 구조로 집계 출력</li> </ul> </li> <li>UNION ALL로 대체 가능 : 빈 컬럼 NULL로 맞춰줘야함</li> <li>ROLLUP ((A, B)) <ul> <li>이런 식으로 괄호를 두 번 감싸면 컬럼별 집계와 전체 집계만 출력 가능</li> </ul> </li> </ul> <h4 id="cubeab">CUBE(A,B)</h4> <ul> <li>모든 조합의 경우의 수 모두 출력</li> <li>나열 대상의 순서 중요X</li> <li>UNION ALL, GROUPING SETS로 대체 가능</li> </ul> <h4 id="grouping">GROUPING()</h4> <ul> <li>Microsoft Learn의 SQL Server 페이지 설명은 다음과 같음 <blockquote> <p>Indicates whether <strong>a specified column expression in a GROUP BY list is aggregated or not.</strong><br/> GROUPING returns 1 for aggregated or 0 for not aggregated in the result set.<br/>GROUPING can be used only in the SELECT &lt;select&gt; list, HAVING, and ORDER BY clauses when GROUP BY is specified.</p> </blockquote> </li> <li>공식 정의에 따르면 ‘<strong>GROUP BY 절에서 지정한 컬럼</strong>에 대한 <strong>집계생성 여부</strong>를 반환한다’는 의미 <ul> <li><code>해당 컬럼이 집계되었다면 0, 그 외 1</code></li> </ul> </li> <li>ROLLUP, CUBE, GROUPING SETS 함수가 리턴하는 NULL과 일반 NULL을 구분하기 위해 사용 <ul> <li>위 함수들이 리턴하는 NULL은 column placeholder 역할을 함</li> </ul> </li> <li>하지만 이 설명은 뭔가 복잡함. 그래서 대부분 아래처럼 정의하는 듯함. 아래 설명이 직관적으로 더 쉽게 이해되지만 GROUPING 함수의 용도를 잘 기억하자! <br/></li> <li>GROUP BY 결과로 “NULL이 생성된 경우” 1을 리턴하는 함수 <ul> <li>GROUP BY 결과에 NULL이 있으면 : 1</li> </ul> </li> <li>GROUP BY 절 필수! <ul> <li>위 조건을 충족하면, SELECT 절 / HAVING 절 / ORDER BY 절에서만 사용가능</li> </ul> </li> </ul> <h3 id="4-윈도우-함수">4. 윈도우 함수</h3> <ul> <li>서로 다른 행의 비교나 연산을 위해 만든 함수 <ul> <li>GROUP BY 안쓰고 그룹 연산</li> </ul> </li> <li><strong>OVER</strong> 절 필수! <ul> <li>OVER 절을 이용해서 <u>그룹함수를 윈도우 함수</u>로 활용</li> </ul> </li> <li><strong>전달 순서</strong> 중요!! <pre><code class="language-sql">SELECT 윈도우함수(대상) OVER([PARTITION BY 컬럼]
[ORDER BY 컬럼 ASC|DESC]
[ROWS|RANGE BETWEEN A AND B]);
</code></pre> </li> <li>PARTITION BY 절 : 윈도우 함수의 GROUP BY 컬럼(그룹연산 수행하는 기준)</li> <li>ORDER BY 절 : RANK 경우 필수! <ul> <li>SUM, AVG, MIN, MAX, COUNT : 누적값 출력시 사용</li> </ul> </li> <li><code>ROWS | RANGE BETWEEN A AND B</code> : 연산 범위 설정 <ul> <li><strong>ORDER BY 절 필수</strong></li> </ul> </li> </ul> <p><br/></p> <h4 id="연산-범위-설정-가능">연산 범위 설정 가능</h4> <ul> <li>ROWS / RANGE <ul> <li>ROWS : 값이 같더라도 각 행씩 연산</li> <li>RANGE : 같은 값의 경우 하나의 RANGE로 묶어서 동시 연산</li> </ul> </li> <li>BETWEEN A AND B <ul> <li>A : 시작점 정의 <ul> <li>CURRENT ROW : 현재 계산/입력중인 행부터 <ul> <li>행 단위로 이동</li> </ul> </li> <li>UNBOUNDED <strong>PRECEDING</strong> : 처음부터(default) <ul> <li>해당 파티션 영역의 가장 처음 행</li> </ul> </li> <li>N <strong>PRECEDING</strong> : N 이전부터</li> </ul> </li> <li>B : 마지막 시점 정의 <ul> <li>CURRENT ROW : 현재 계산/입력중인 행까지(default) <ul> <li>행 단위로 이동</li> </ul> </li> <li>UNBOUNDED <strong>FOLLOWING</strong> : 마지막까지 <ul> <li>해당 파티션 영역의 가장 마지막 행</li> </ul> </li> <li>N <strong>FOLLOWING</strong> : N 이후까지</li> </ul> </li> </ul> </li> </ul> <h4 id="순위-관련">순위 관련</h4> <ul> <li><em>비교문제 많이 나옴!</em> <br/></li> <li>RANK(값) : 특정 값에 대한 순위 확인 <ul> <li>윈도우 함수X - 일반 함수</li> <li><strong>RANK() OVER()</strong> : 윈도우 함수 형태 <ul> <li>ORDER BY 절 필수</li> <li>전체/특정 그룹 중 값의 순위 확인 <ul> <li>동순위 데이터 수에 따라 다음 순위 결정됨(1등 3명이면 그다음 순위 4등)</li> </ul> </li> </ul> </li> </ul> </li> <li>DENSE_RANK : 누적순위 <ul> <li>동순위 다음 순위가 바로 이어짐(1등 4명이어도 그다음 순위가 2등)</li> </ul> </li> <li>ROW_NUMBER : 연속된 행 번호 <ul> <li>동순위 인정X, 나열한 순서대로의 값 출력(동순위 없이 순서-1, 2, 3…)</li> </ul> </li> </ul> <h4 id="비교-관련">비교 관련</h4> <ul> <li><strong>LAG, LEAD</strong> : 행순서대로 각각 이전 값(LAG), 이후 값(LEAD) 가져옴 <ul> <li><strong>ORDER BY</strong> 절 필수 <ul> <li>e.g. 바로 이전 입사자와 급여 비교</li> </ul> </li> <li>SQL Server에서는 지원X</li> </ul> </li> <li><code>LAG (scalar_expression [, offset [, default ]]) OVER ( [ partition_by_clause ] order_by_clause)</code> <ul> <li>offset : The number of rows back from the current row from which to obtain a value. If not specified, the default is 1. <ul> <li>출처 : <a href="https://www.geeksforgeeks.org/sql-server-lag-function-overview/">Geeksforgeeks</a></li> </ul> </li> </ul> </li> <li><strong>FIRST_VALUE, LAST_VALUE</strong> : 정렬 순서대로</li> <li><strong>NTILE</strong> : 정해진 수의 그룹으로 나누기 위한 함수 <ul> <li>그룹 번호 리턴</li> <li><strong>ORDER BY</strong> 절 필수</li> </ul> </li> </ul> <h4 id="비율-관련">비율 관련</h4> <ul> <li><em>시험 자주 출제</em> <br/></li> <li>RATIO_TO_REPORT : 각 값의 비율 리턴 <ul> <li><strong>ORDER BY 절 X</strong></li> </ul> </li> <li>CUME_DIST : 누적 비율 <ul> <li><strong>ORDER BY</strong> 절 필수 <ul> <li>누적 비율 구하는 순서 정함</li> </ul> </li> </ul> </li> <li>PERCENT_RANK : 분위수 출력 <ul> <li>전체 COUNT 중 상대적 위치 출력</li> <li><strong>ORDER BY</strong> 절 필수</li> </ul> </li> </ul> <h3 id="5-top-n-query">5. TOP N QUERY</h3> <ul> <li>전체 결과에서 특정 N개 추출</li> <li>ROWNUM : 출력 데이터 기준으로 행 번호 부여 <ul> <li>특정 행 지정X</li> <li><code>&lt;=</code>, <code>&gt;=</code> 연산자는 사용 가능</li> </ul> </li> <li>RANK</li> <li>FETCH : 출력될 행의 수 제한</li> </ul> <h3 id="6-계층형-질의">6. 계층형 질의</h3> <ul> <li>하나의 테이블 내 각 행끼리의 관계를 가질때, 연결고리로 행-행 사이의 계층을 표현</li> <li>PRIOR 위치에 따라 연결 데이터가 달라짐 <ul> <li>오라클 계층형 질의문에서 PRIOR 키워드는 SELECT, WHERE 절에서도 사용가능!</li> </ul> </li> <li>SQL Server에서는 CTE(Common Table Expression)을 재귀호출해서 계층 구조 전개 <ul> <li>앵커 멤버를 실행 → 기본결과 집합 생성</li> <li>이후 재귀 멤버를 지속적으로 생성 <pre><code class="language-sql">SELECT 
FROM 테이블 명
START WITH 시작조건
CONNECT BY PRIOR 연결조건;
</code></pre> </li> </ul> </li> <li>START WITH : 데이터 출력할 시작 지정하는 조건 <ul> <li>해당 데이터가 있는 행이 <strong>LEVEL 1</strong> : 루트노드</li> <li>START WITH 절에 해당하는 행은 조건절과 상관없이 결과에 출력됨</li> </ul> </li> <li>CONNECT BY PRIOR : 시작점을 기준으로 하위 레벨을 찾아가는 조건 <ul> <li>행을 이어나갈 조건</li> <li>CONNECT BY절의 PRIOR 바로 다음에 있는 컬럼을 기준으로 ‘=’ 이후의 컬럼과 맞췄을때 같은 데이터가 있는 행이 LEVEL 2</li> </ul> </li> </ul> <h4 id="계층형-질의-가상-컬럼">계층형 질의 가상 컬럼</h4> <ul> <li>LEVEL : 각 DEPTH 를 표현(시작점부터 1)</li> <li>CONNECT_BY_ISLEAF : LEAF NODE(최하위노드) 여부 <ul> <li>참:1, 거짓:0</li> </ul> </li> </ul> <h4 id="계층형-질의-가상-함수">계층형 질의 가상 함수</h4> <ul> <li>CONNECT_BY_ROOT 컬럼명 : 루트노드의 해당 컬럼명의 값이 출력</li> <li>SYS_CONNECT_BY_PATH(컬럼, 구분자) : 이어지는 경로 출력</li> <li>ORDER SIBLINGS BY 컬럼 : 같은 LEVEL 일 경우 정렬 수행</li> </ul> <h3 id="7-pivot--unpivot">7. PIVOT / UNPIVOT</h3> <ul> <li>데이터 구조를 변경하는 기능</li> <li>LONG DATA : 하나의 속성 = 하나의 컬럼</li> <li>WIDE DATA : 하나의 속성값이 여러 컬럼으로 분리되어 표현 <ul> <li>JOIN 연산 불가</li> <li>값이 추가될때마다 컬럼 추가되야함(비효율적)</li> </ul> </li> </ul> <h4 id="pivot">PIVOT</h4> <ul> <li>LONG -&gt; WIDE <ul> <li>교차표를 만드는 기능</li> </ul> </li> <li>STACK, UNSTACK, VALUE 컬럼 정의 중요!</li> <li>FROM 절에는 : STACK, UNSTACK, VALUE 컬럼명만 정의(다른 컬럼 정보 들어가면 포함됨) <ul> <li>명시하고 싶은 데이터만 <strong>sub qeury로 컬럼제한</strong> 필수!!</li> </ul> </li> <li>PIVOT 절에는 : UNSTACK, VALUE 컬럼명 정의 <ul> <li>PIVOT 절에 선언한 UNSTACK, VALUE 컬럼 제외한 모든 컬럼이 STACK 컬럼이 됨!</li> </ul> </li> </ul> <h4 id="unpivot">UNPIVOT</h4> <ul> <li>WIDE -&gt; LONG</li> <li>만들고 싶은 STACK, VAUE 컬럼 지정 : 컬럼명 전달</li> <li>value1, value2 … : 실제 UNSTACK 되어있는 컬럼명 <pre><code class="language-sql">SELECT *
FROM 테이블명 혹은 서브쿼리
UNPIVOT (VALUE컬럼명 FOR STACK컬럼명 IN (value1, value2...));
</code></pre> </li> <li>IN 뒤의 값으로 <ul> <li>숫자 전달할 경우(UNSTACK 데이터 컬럼명이 숫자인 경우) <strong>” “ 쌍따옴표</strong>로 전달</li> <li>문자 - 대명사(객체 이름)은 쌍따옴표 붙이지 X</li> </ul> </li> </ul> <h3 id="8-정규-표현식">8. 정규 표현식</h3> <ul> <li>문자열의 공통된 규칙을 일반화하여 표현 <ul> <li>규칙을 찾아내면 일일이 문자를 나열하지 않아도 되는 장점</li> </ul> </li> <li><code>\d</code>: 숫자 - <code>\D</code> : 숫자 아닌것</li> <li><code>\w</code>: 단어(<code>_</code> 언더스코어 포함) - <code>\W</code> : 특수문자(<code>_</code> 빼고)</li> <li><code>^</code>ab<code>$</code> : a로 시작하고 b로 끝나는(사용 위치 주의)</li> <li><code>[]</code> : 한 글자로 취급 <ul> <li>[][] : 이렇게 되면 두 글자</li> </ul> </li> <li><code>i*</code> / <code>i?</code> : i가 있거나 없거나</li> <li><code>\</code> : 기호의미 사용하지 않고 기호 자체를 사용하는 경우 <ul> <li>e.g. <code>tel\)</code> : tel)</li> </ul> </li> <li>[[:punct:]] : 특수기호</li> <li><code>.+</code> : 엔터를 제외한 모든것</li> <li><code>^ </code> : 공백을 제외한 모든것 = 단어 <br/></li> <li>REGEXP_REPLACE : 치환 <ul> <li>바꿀문자열 생략 시 문자열 삭제 <ul> <li>문자열 비어있으면 모두 삭제됨</li> </ul> </li> <li>검색위치 생략 시 1</li> <li>발견횟수 생략 시 0(모든)</li> </ul> </li> <li>REGEXP_SUBSTR : 추출 <ul> <li><code>REGEXP_SUBSTR(대상, 패턴, [검색위치], [발견횟수], [옵션], [추출그룹])</code> <ul> <li>추출그룹 = 서브패턴 번호 쓰려면 앞의 옵션 모두 써야함 : 값이 없는 경우 NULL로 채우기</li> </ul> </li> </ul> </li> <li>REGEXP_INSTR : 시작위치</li> <li>REGEXP_LIKE : 필터링 조건 <ul> <li>WHERE 절에서만 사용</li> </ul> </li> <li>REGEXP_COUNT : 특정 패턴 횟수 반환</li> </ul>]]></content><author><name></name></author><category term="study"/><category term="자격증"/><category term="sqld"/><category term="skill-stacking"/><summary type="html"><![CDATA[SQLD 4주차 공부 기록]]></summary></entry><entry><title type="html">SQLD 공부 PART 2 - CH1. SQL 기본</title><link href="https://seulwithlove.github.io/blog/2024/get-sqld-part2-1-2/" rel="alternate" type="text/html" title="SQLD 공부 PART 2 - CH1. SQL 기본"/><published>2024-05-14T00:00:00+00:00</published><updated>2024-05-14T00:00:00+00:00</updated><id>https://seulwithlove.github.io/blog/2024/get-sqld-part2-1-2</id><content type="html" xml:base="https://seulwithlove.github.io/blog/2024/get-sqld-part2-1-2/"><![CDATA[<h2 id="sqld---week-4---part2---ch1-sql-기본">SQLD - Week 4 - Part2 - CH1. SQL 기본</h2> <ul> <li>유튜브 &lt;<a href="https://www.youtube.com/@hdatalab">홍쌤의 데이터랩</a>&gt;, 강의자료 단권화</li> <li>책 &lt;2023 유선배 SQL개발자(SQLD) 과외노트&gt; 참고</li> </ul> <h3 id="1-함수">1. 함수</h3> <ul> <li>문자형, 숫자형, 날짜형, 변환 함수 : 단일행 함수</li> </ul> <h4 id="문자함수">문자함수</h4> <ul> <li><strong>CONCAT(대상1, 대상2)</strong> : 문자열 결합 <ul> <li>= <code>대상1 || 대상2</code><br/> |</li> </ul> </li> </ul> <h4 id="날짜형-함수">날짜형 함수</h4> <ul> <li><strong>DATE_FORMAT(날짜, 형식)</strong> <ul> <li>Oracle 환경은 지원X</li> <li><strong>TO_CHAR</strong> / <strong>TO_DATE</strong> 활용</li> </ul> </li> </ul> <table> <thead> <tr> <th>구분기호</th> <th>역할</th> <th>구분기호</th> <th>역할</th> </tr> </thead> <tbody> <tr> <td>%Y</td> <td>4자리 연도</td> <td>%m</td> <td>숫자 월(두자리)</td> </tr> <tr> <td>%y</td> <td>2자리 연도</td> <td>%c</td> <td>숫자 월(한자리는 한자리)</td> </tr> <tr> <td>%M</td> <td>긴 월(영문)</td> <td>%d</td> <td>일자(두자리)</td> </tr> <tr> <td>%b</td> <td>짧은 월(영문)</td> <td>%e</td> <td>일자(한자리는 한자리)</td> </tr> <tr> <td>%W</td> <td>긴 요일(영문)</td> <td>%l</td> <td>시간(12시간)</td> </tr> <tr> <td>%a</td> <td>짧은 요일(영문)</td> <td>%H</td> <td>시간(24시간)</td> </tr> <tr> <td>%i</td> <td>분</td> <td>%r</td> <td>hh:mm:ss AM, PM</td> </tr> <tr> <td>%T</td> <td>hh:mm:SS</td> <td>%S</td> <td>초</td> </tr> </tbody> </table> <ul> <li><em>이 표는 오라클에서는 필요없는건가?</em></li> </ul> <h4 id="그룹함수">그룹함수</h4> <ul> <li>복수행 함수(여러 행이 요약되어 하나로 나옴)</li> <li><strong>NULL 무시</strong>하고 연산(데이터 없는 취급) <ul> <li>COUNT할때 NULL 데이터는 세지 않음</li> </ul> </li> </ul> <table> <thead> <tr> <th>함수명</th> <th>출력내용</th> <th>쿼리문 예시</th> </tr> </thead> <tbody> <tr> <td>COUNT</td> <td>행의 수</td> <td>SELECT COUNT(SAL) FROM EMP;</td> </tr> <tr> <td>SUM</td> <td>총 합</td> <td>SELECT SUM(SAL) FROM EMP;</td> </tr> <tr> <td>AVG</td> <td>평균</td> <td>SELECT AVG(SAL) FROM EMP;</td> </tr> <tr> <td>MIN</td> <td>최솟값</td> <td>SELECT MIN(SAL) FROM EMP;</td> </tr> <tr> <td>MAX</td> <td>최댓값</td> <td>SELECT MAX(SAL) FROM EMP;</td> </tr> <tr> <td>VARIANCE</td> <td>분산</td> <td>SELECT VARIANCE(SAL) FROM EMP;</td> </tr> <tr> <td>STDDEV</td> <td>표준편차</td> <td>SELECT STDDEV(SAL) FROM EMP;</td> </tr> </tbody> </table> <h4 id="일반함수">일반함수</h4> <ul> <li><strong>DECODE(대상, 값1, 리턴 1, 값2, 리턴2, …, 그외리턴)</strong> : 대상이 값 1이면 리턴 1, 값2면 리턴2, .. 그 외에는 그외리턴</li> <li><strong>CASE</strong> : 조건 활용 <pre><code class="language-sql">SELECT 
  CASE 
    WHEN(조건A) THEN A 
    WHEN(조건B) THEN B 
      ELSE C 
  END AS 원하는 컬럼명 
FROM TABLE ;	
</code></pre> </li> <li>조건에 ‘=’만 있으면 “단순 CASE 표현식”으로 변환가능 <ul> <li>e.g. CASE WHEN LOC = ‘NEW YORK’ THEN ‘EAST’ <ul> <li>CASE LOC WHEN ‘NEW YORK’ THEN ‘EAST’</li> </ul> </li> </ul> </li> </ul> <h4 id="null-치환-함수-️">NULL 치환 함수 ⭐️</h4> <ul> <li><strong>NVL(대상, 치환값)</strong> : 대상이 NULL이면 치환값 으로 리턴 <ul> <li>SQL Server환경 : <strong>ISNULL(대상, 치환값)</strong></li> </ul> </li> <li><strong>NULLIF(표현식1, 표현식2)</strong> : 표현식1 = 표현식2 이면 NULL, 다르면 표현식 1 리턴</li> <li><strong>COALESCE(대상1, 대상2, 대상3,…, 그외리턴)</strong> : 대상 1을 리턴하는데, NULL인 경우 차례차례 다음 값을 리턴 <ul> <li>다 NULL인 경우 (그외 리턴 없다면) NULL 리턴</li> </ul> </li> </ul> <h4 id="오답노트">오답노트</h4> <ul> <li><span style="color:blue;">SELECT MOD(-15, 0) FROM DUAL;</span> <ul> <li>정답: -15</li> <li>MOD 함수의 두 번째 인자가 0이면 첫 번째 인자값이 결과로 도출</li> </ul> </li> <li><span style="color:blue;">SELECT MOD(-15, -4) FROM DUAL;</span> <ul> <li>정답: -3</li> <li>MOD 함수의 두 인자값이 모두 음수이면 나머지도 음수로 도출</li> </ul> </li> </ul> <h3 id="2-where-절">2. WHERE 절</h3> <ul> <li>조건에 맞는 데이터만 조회하고 싶을때</li> <li>여러 조건 동시 전달 : AND, OR</li> <li><strong>NULL 관련 조회</strong>하려면 : <code>IS NULL</code> / <code>IS NOT NULL</code> 연산자 사용 <ul> <li><code>WHERE COL1 = NULL</code> 이렇게 사용 X : 이 연산결과는 False</li> </ul> </li> <li>데이터 타입을 일치시켜서 비교 조건문 생성</li> <li>문자나 날짜 상수 표현할때 <code>' '</code> 홑따옴표 사용</li> <li>ORACLE은 문자 상수 → 대소문자 구분함</li> <li>논리연산자 : ( ) → NOT → AND → OR 순으로 처리</li> <li>Group function 집계함수(SUM, COUNT…)는 사용할수 없음 <ul> <li>GROUP BY / HAVING 절에서 사용</li> </ul> </li> <li>참고) <ul> <li>WHERE 절은 <strong>데이터 집합의 높이</strong>를 변화시킴</li> <li>SELECT 절은 <strong>데이터 집합의 넓이</strong>를 변화시킴</li> <li>출처: <a href="https://sweetquant.tistory.com/568">Sweet DataStory</a></li> </ul> </li> </ul> <h3 id="3-group-by-절">3. GROUP BY 절</h3> <ul> <li>특정 조건에 따라 컬럼을 그룹핑</li> <li>비교적 많은 비용이 드는 작업이므로 WHERE 절에서 데이터량을 최소로 줄이는게 좋음</li> <li>그룹별 요약 결과가 도출됨 <ul> <li>주의 : SELECT 절에 요약하지 않은 정보는 사용할수 없음 <ul> <li>GROUP BY 절에서 사용할 컬럼이 아니라면, 그룹함수로만 불러올수 있음!</li> <li>e.g. <pre><code class="language-sql">SELECT DEPTNO, MAX(SAL), ENAME
FROM EMP
GROUP BY DEPTNO;
</code></pre> <ul> <li>ENAME 때문에 에러발생!</li> <li>DEPTNO로 그룹핑했기때문에 ENAME은 그룹함수 없이 불러올수 없음</li> </ul> </li> </ul> </li> </ul> </li> </ul> <h3 id="4-having-절">4. HAVING 절</h3> <ul> <li>GROUP BY 절의 조건절 역할(WHERE 과 동일한 역할)</li> <li><strong>집계함수 활용</strong></li> <li>SELECT 절 전에 수행됨 = SELECT 절에서 선언한 Alias 사용 X</li> <li>WHERE 절에서 사용해도 될 조건까지 포함하지 않도록 조심</li> </ul> <h3 id="5-order-by-절">5. ORDER BY 절</h3> <ul> <li>SELECT한 데이터를 정렬 : 가장 마지막에 실행되는 절 <ul> <li>SELECT 절 다음 실행 : SELECT 절의 Alias 사용 가능</li> </ul> </li> <li>따로 명시하지않으면 임의의 순서로 출력됨</li> <li>ASC(Ascending) 오름차순이 기본값 (작 → 커)</li> <li>여러개의 기준 사용 가능</li> <li>NULL 관련 옵션 : NULL FIRST / NULL LAST <ul> <li>Oracle 기준, NULL은 최댓값</li> </ul> </li> </ul> <h3 id="6-join">6. JOIN</h3> <ul> <li>여러 테이블 데이터를 한번에 보여줄때 사용</li> <li>FROM 절에 조인할 테이블 나열</li> <li>WHERE 절에 조인 조건 작성</li> <li>ORACLE 표준 / ANSI 표준 다름 : 구분!!</li> <li>일대다 관계가 성립할때 조인 가능 (Primary Key PK / Foreign Key FK)</li> </ul> <p><strong>[PRIMARY KEY(PK) 기본키]</strong></p> <ul> <li>유일한 식별자(각 행을 구별할수 있는 식별자 기능) <ul> <li><strong>UNIQUE + NOT NULL</strong></li> </ul> </li> <li>테이블 1개 - PK 1개 - 컬럼 여러개</li> </ul> <p><strong>[FOREIGN KEY]</strong></p> <ul> <li>자식테이블에 거는 장치</li> <li>부모 테이블을 참조하면서 관리</li> </ul> <h4 id="종류">종류</h4> <ol> <li>조건의 형태에 따라 <ul> <li>EQUI JOIN(=) : 동등 조건</li> <li>NON EQUI JOIN(&lt;, &gt;, &gt;=, &lt;=) : 동등 조건이 아닌 경우</li> </ul> </li> <li>조인 결과에 따라 <ul> <li>INNER JOIN : 조건에 성립하는 데이터만 출력</li> <li>OUTER JOIN : 조건에 성립하지 않는 데이터도 출력</li> </ul> </li> <li>NATURAL JOIN : 조인조건 없이 컬럼명이 같을때 사용 <ul> <li>조인조건 생략시 두 테이블에 같은 이름으로 자연 연결됨</li> </ul> </li> <li>CROSS JOIN : 조건없이 조인하는경우 = 잘못된 조인방법 <ul> <li>조인조건 생략시 두 테이블의 발생 가능한 모든 행을 출력</li> </ul> </li> <li>SELF JOIN : 하나의 테이블을 두 번 이상 참조해서 연결</li> </ol> <h3 id="7-standard-join--ansi-join">7. STANDARD JOIN = ANSI JOIN</h3> <ul> <li>ANSI 표준 방식 <ul> <li>INNER JOIN, OUTER JOIN, CROSS JOIN, NATURAL JOIN</li> </ul> </li> <li>JOIN 조건은 ‘ON 절’로 사용</li> </ul> <h4 id="inner-join">INNER JOIN</h4> <ul> <li>내부 조인 : 조인 조건이 일치하는 데이터만 추출</li> <li> <p>FROM 절에 ‘INNER JOIN / JOIN’이라고 명시</p> <pre><code class="language-sql">SELECT 컬럼명
  FROM 테이블1 INNER JOIN 테이블2
    ON 테이블1.조인컬럼 = 테이블2.조인컬럼;
</code></pre> </li> <li><strong>USING</strong> / <strong>ON</strong> 조건절을 필수로 사용! <ul> <li>ON <ul> <li>JOIN 조건 명시(WHERE 절에서 일반 조건 명시)</li> <li>ON 조건의 괄호는 옵션(생략가능) <pre><code class="language-sql">SELECT 테이블1.컬럼명, 테이블2.컬럼명
FROM 테이블1 INNER JOIN 테이블2
  ON 테이블1.조인컬럼 = 테이블2.조인컬럼;
</code></pre> </li> </ul> </li> <li>USING <ul> <li>JOIN 할 컬럼명이 같을때 사용하는 JOIN 조건절</li> <li>괄호 필수!(생략X) <pre><code class="language-sql">SELECT 테이블1.컬럼명, 테이블2.컬럼명
FROM 테이블1 INNER JOIN 테이블2
 USING (동일컬럼명);
</code></pre> </li> <li>만약, ON 조건처럼 사용하면 SYNTAX ERROR</li> </ul> </li> </ul> </li> </ul> <h4 id="natural-join">NATURAL JOIN</h4> <ul> <li>동일한 컬럼명에 대해 EQUI JOIN</li> <li>USING, ON, WHERE절 사용 X(조건 명시X)</li> </ul> <h4 id="outer-join">OUTER JOIN</h4> <ul> <li>JOIN 조건에서 일치하지 않는 행(동일한 값이 없는 행, 두 테이블의 교차바깥영역)을 출력하고 싶을때 사용 <ul> <li>EQUI JOIN에서는 NULL이 있으면 출력 X -&gt; 이럴때도 사용</li> </ul> </li> <li>테이블 기준 방향 지정해야함 <br/> <ol> <li><strong>LEFT OUTER JOIN</strong></li> </ol> </li> <li>FROM절에 나열된 왼쪽 테이블에 해당하는 데이터를 읽은 후, 우측 테이블에서 JOIN 대상 읽어옴 <ul> <li>왼쪽 테이블 기준, 오른쪽 테이블 데이터를 채우는 방식</li> </ul> </li> <li>우측 테이블에서 왼쪽테이블과 같은 같이 없는 경우 NULL 출력 <br/> </li> </ul> <ol> <li>RIGHT OUTER JOIN <ul> <li>LEFT OUTER JOIN의 반대 <ul> <li>오른쪽 테이블 기준, 왼쪽 테이블 데이터를 채우는 방식</li> </ul> </li> <li>FROM절의 테이블 순서를 변경하면 LEFT OUTER JOIN으로 수행 가능 <br/> </li> </ul> </li> <li>FULL OUTER JOIN <ul> <li>두 테이블 전체 기준으로 결과를 생성 → <strong>중복 데이터는 하나만 남기고 삭제</strong> 후 리턴</li> <li><code>'LEFT OUTER JOIN 결과' UNION 'RIGHT OUTER JOIN 결과'</code>와 동일 <ul> <li>ORACLE 표준에는 없음 <pre><code class="language-sql">SELECT column_name(s)
FROM table1
FULL OUTER JOIN table2
ON table1.column_name = table2.column_name
WHERE condition;
</code></pre> </li> </ul> </li> </ul> </li> </ol>]]></content><author><name></name></author><category term="study"/><category term="자격증"/><category term="sqld"/><category term="skill-stacking"/><summary type="html"><![CDATA[SQLD 4주차 공부 기록]]></summary></entry><entry><title type="html">SQLD 공부 - DB 환경세팅</title><link href="https://seulwithlove.github.io/blog/2024/get-sqld-db-env-setting/" rel="alternate" type="text/html" title="SQLD 공부 - DB 환경세팅"/><published>2024-05-13T00:00:00+00:00</published><updated>2024-05-13T00:00:00+00:00</updated><id>https://seulwithlove.github.io/blog/2024/get-sqld-db-env-setting</id><content type="html" xml:base="https://seulwithlove.github.io/blog/2024/get-sqld-db-env-setting/"><![CDATA[<h2 id="sqld---week-3---환경세팅">SQLD - Week 3 - 환경세팅</h2> <ul> <li>주피터노트북에서 PostgreSQL 패키지 <em>psycopg2-binary</em>를 활용해 SQL을 사용하도록 환경세팅 <ul> <li>참고자료 : <a href="https://datalore.jetbrains.com/report/static/0k5R4AZgfYFgpwZkcb3f7G/F4dVZDGdekdgiJ8PKPUQ4w">Jetbrain tutorial</a>, <a href="https://www.bearpooh.com/147">Blog - 곰탱푸닷컴</a>, <a href="https://www.youtube.com/watch?v=le_GyH6kZTo">Youtube - Tech with Byron</a></li> </ul> </li> <li>Mac에서 Oracle DB 사용하도록 환경 세팅 <ul> <li>참고자료 :<br/> Blog - <a href="https://intheham.tistory.com/23">함함ː</a>, <a href="https://velog.io/@devsaza/M1-M2-Mac-OS%EC%97%90%EC%84%9C-Oracle-DB-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">사자</a>, <a href="https://shanepark.tistory.com/">Shane’s planet</a>, <a href="https://velog.io/@wheezy_han/DBeaver">wheezy</a>, <a href="https://velog.io/@sangwoong/Database-DBeaver">김상웅</a>, <br/> <a href="https://dbeaver.io/">DBeaver Community</a></li> </ul> </li> <li>책 &lt;2023 유선배 SQL개발자(SQLD) 과외노트&gt;로 기본 이론 단권화 <ul> <li>챕터 3 정리</li> <li>유튜브 &lt;<a href="https://www.youtube.com/@hdatalab">홍쌤의 데이터랩</a>&gt;, 강의자료 참고</li> </ul> </li> <li>SQL문 실습 내용은 추후 포스팅 예정</li> </ul> <h3 id="주피터노트북--postgresql-연결">주피터노트북 + PostgreSQL 연결</h3> <h4 id="using-magic-command">Using Magic Command</h4> <ul> <li>주피터노트북의 매직명령어를 사용해서 쉽게 postgresDB를 사용 <ul> <li>판다스를 활용한 방식도 시도해보았지만, SQL문 작성 방식이 시험공부하기엔 적절하지 않은 것같아서 주피터노트북의 매직명령어를 사용하는 방법으로 최종 결정</li> </ul> </li> <li>but, 실습에서 반복해서 나오는 <code>DUAL</code> 테이블을 사용할수 없음! <ul> <li>사실 dual 테이블은 갑자기 어디에서 나왔는지, 책에 있는 예제 실습은 어떻게 해야할지 감이 없어서 한참을 헤맸다😇</li> </ul> </li> </ul> <h4 id="dual-table">Dual table?</h4> <blockquote> <p>The DUAL is special one row, one column table present by default in all Oracle databases. (<a href="https://www.w3resource.com/sql/sql-dual-table.php">w3resource</a>)</p> </blockquote> <ul> <li>간단하게 함수를 이용해서 계산 결과를 확인할때 사용하는 일종의 dummy table <ul> <li>오라클에서 제공하는 테이블이기때문에 사용이 어려움!</li> </ul> </li> <li>Oracle DB를 추가 세팅해서 주피터노트북에서 사용이 안되는 쿼리문을 테스트해보기로 결정</li> </ul> <h3 id="mac에서-oracle-db-사용">MAC에서 Oracle DB 사용</h3> <h4 id="using-docker-colima">Using Docker, Colima</h4> <ul> <li>블로그마다 유저세팅하고 테스트하는 DB가 HR DB였지만, 24년인 지금은 최신DB xe로 설치하게 되면 해당 DB는 포함이 안되있어서 User 세팅부분에서 에러가 발생 <ul> <li>이것도 한참 헤맸지만 앞서 길을 걸어갔던 <a href="https://intheham.tistory.com/23">블로거</a>분 덕분에 헤매는걸 멈출수 있었다 (<em>자세한 포스팅을 올려주셔서 무한 감사를…</em>)</li> <li>그래도 여러 블로그를 반복해서 보고 테스트하다보니 오히려 docker 기본 사용법을 익히게 되었다 굿!</li> </ul> </li> <li>HR DB를 사용할필요가 없다면 이 <a href="https://velog.io/@devsaza/M1-M2-Mac-OS%EC%97%90%EC%84%9C-Oracle-DB-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">블로그-1</a>를 추천! 그대로만 진행하면 세팅 완료! (만약 좀더 자세한 설명이 필요하다면: <a href="https://shanepark.tistory.com/400">블로그-2</a>) (<em>이 두 분께도 무한 감사를…</em>)</li> </ul> <h4 id="-hr-데이터베이스를-사용하는-경우">👉 HR 데이터베이스를 사용하는 경우,</h4> <ol> <li> <p>Docker, colima 설치 완료한 이후 터미널에서 아래 순서대로 진행 (참고: <a href="https://velog.io/@devsaza/M1-M2-Mac-OS%EC%97%90%EC%84%9C-Oracle-DB-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">위 블로그</a>에서 colima 설치까지!)</p> </li> <li> <p>oracle 11g 버전 찾아서, pull</p> </li> </ol> <ul> <li> <p><code>jaspeen/oracle-xe-11g</code> 버전으로 골라야 한다</p> <pre><code class="language-shell">docker search oracle-xe-11g

docker pull jaspeen/oracle-xe-11g
</code></pre> <p><img src="https://github.com/seulwithlove/seulwithlove/assets/140625136/b61452e2-43fd-42cf-88e7-a0b1c36f98fc" alt="Screenshot 2024-05-13 at 22 14 22"/><br/> <img src="https://github.com/seulwithlove/seulwithlove/assets/140625136/a736c513-bc5e-45f0-91e2-17d8e03a9ed7" alt="Screenshot 2024-05-13 at 22 14 55"/></p> </li> </ul> <ol> <li>도커 컨테이너 생성</li> </ol> <ul> <li>명령어가 길어서 보기 편하도록 <code>\</code>로 구분했지만 한 줄에 이어서 써도 상관없다 <pre><code class="language-shell">docker run \
 --restart unless-stopped \
 --name oracle \
 -e ORACLE_PASSWORD=oracle \
 -p 1521:1521 \
 -d \
 jaspeen/oracle-xe-11g
</code></pre> <p><img src="https://github.com/seulwithlove/seulwithlove/assets/140625136/766b0ded-00f7-435a-80f9-499c5c85d086" alt="Screenshot 2024-05-13 at 22 15 11"/></p> </li> </ul> <ol> <li>컨테이너 로그 확인</li> </ol> <ul> <li>명령어로 해당 컨테이너가 잘 생성되었는지 확인을 먼저 해보고 <pre><code class="language-shell">docker ps -a
</code></pre> <p><img src="https://github.com/seulwithlove/seulwithlove/assets/140625136/91058da7-c9c8-40c1-aae0-1a6db0bb5d43" alt="Screenshot 2024-05-13 at 22 15 21"/></p> </li> <li>해당 컨테이너 로그 확인 <pre><code class="language-shell">docker logs -f oracle
</code></pre> <p><img src="https://github.com/seulwithlove/seulwithlove/assets/140625136/2f44026f-d7ef-491e-a8e6-cbe32a6fe6da" alt="Screenshot 2024-05-13 at 22 16 05"/></p> <ul> <li>위 이미지대로 뜬다면 Oracle DB 설치 완료</li> </ul> </li> </ul> <h4 id="using-dbeaver">Using DBeaver</h4> <ul> <li>RDBMS를 사용하기 위해 pgAdmin4 혹은 SQL Developer를 이용해도 되지만 <strong>DBeaver</strong>를 사용해보기로 결정!</li> <li>특징 <blockquote> <p>DBeaver Community is a <strong>free cross-platform database tool</strong> for developers, database administrators, analysts, and <strong>everyone working with data</strong>. It <strong>supports all popular SQL databases</strong> like <u>MySQL, MariaDB, PostgreSQL, SQLite, Apache Family</u>, and more. - <a href="https://dbeaver.io/">DBeaver Community</a></p> </blockquote> <ul> <li>여러가지 데이터베이스(Oracle, PostgreSQL, MySQL, A…)를 지원하는 통합 데이터베이스 툴</li> <li>오픈소스</li> <li>직관적인 인터페이스</li> <li>크로스플랫폼 지원: Mac OS, Windows, Linux</li> </ul> </li> </ul> <h4 id="-oracle-db---dbeaver-연결">👉 Oracle DB - DBeaver 연결</h4> <ul> <li>위의 가이드대로 연결했다면, <blockquote> <p>Host: localhost<br/> Port: 1521<br/> Database: xe<br/> Username: system<br/> Password: oracle</p> </blockquote> </li> <li>Test Connection 눌러서 연결 확인후 Finish!</li> <li>Query Console을 열어서 테스트해보면 잘 실행이 된다🥳 <img src="https://github.com/seulwithlove/seulwithlove/assets/140625136/68bd1d97-52f0-4413-ba2f-fabb59012d10" alt="Screenshot 2024-05-13 at 23 28 38"/></li> </ul>]]></content><author><name></name></author><category term="study"/><category term="trouble-shooting"/><category term="자격증"/><category term="sqld"/><category term="skill-stacking"/><summary type="html"><![CDATA[SQLD 3주차 공부 기록]]></summary></entry><entry><title type="html">임팩트닷커리어 커뮤니티 OT 후기</title><link href="https://seulwithlove.github.io/blog/2024/impact_dot_career_community_ot/" rel="alternate" type="text/html" title="임팩트닷커리어 커뮤니티 OT 후기"/><published>2024-05-04T00:00:00+00:00</published><updated>2024-05-04T00:00:00+00:00</updated><id>https://seulwithlove.github.io/blog/2024/impact_dot_career_community_ot</id><content type="html" xml:base="https://seulwithlove.github.io/blog/2024/impact_dot_career_community_ot/"><![CDATA[<blockquote> <p>소셜임팩트를 가진 이, 모두 임팩트닷커리어 커뮤니티로!</p> </blockquote> <h2 id="intro">Intro</h2> <p>지난주 <a href="https://rootimpact.notion.site/520053526dba44b2be3c95149dd8d115">임팩트닷커리어 커뮤니티</a>에 가입하고, 오늘 막 시작한 오리엔테이션 2회차 세션에 참석했다. 어떠한 요청도 받지 않은 “순수한” 마음으로 쓴 이 참석 후기는 임팩트닷커리어 커뮤니티 오리엔테이션 참석을 고민하는 분에게 바람을 듬뿍 넣고자 용기를 내어 작성하는 포스팅이다.</p> <h3 id="impactcareer">Impact.Career</h3> <p>취업을 준비하다 보면 나라는 사람은 사라지고 ‘기업 가치관’ 맞춤형 인간이 되기 마련인데,<br/> <a href="https://impact.career/v2">임팩트닷커리어</a>는 <strong>사회 가치</strong>에 중심을 둔 ‘<strong>내 가치관</strong>‘이 커리어로 연결되도록 응원하는 멋진 곳이다.</p> <p>리브랜딩 전 임팩트커리어는 주로 소셜임팩트 분야 채용공고를 확인하던 사이트였는데, 소셜임팩트에 관심이 있는 이들을 서로 연결하고, 이들이 함께 무언가를 기획하고 활동할수 있는 플랫폼으로 확장한다는 커뮤니티 오픈 소식이 너무나 반가웠다.</p> <h2 id="impactcareer-community-ot">Impact.Career Community OT</h2> <p>두 시간으로 준비된 오리엔테이션은 발견과 감동과 배움이 가득한 가슴 벅찬 시간이었다. 사실 커뮤니티 오리엔테이션을 오프라인으로(!) 두 시간이나(?) 진행한다고 해서 참석이 조금 망설여지기는 했다. 그러나 지금은 이 OT를 많은 이에게 알려야 한다는 사명감이 생겼다!</p> <p>간단한 임팩트닷커리어 커뮤니티(<em>이후로 ‘임닷커’로 줄임</em>) 소개를 받고 나서 가치관 키워드를 중심으로 워크숍이 진행되었다. Part 1, 2로 나뉜 세심하게 설계된 키트의 흐름을 따라가다 보면 어느새 나의 가치관이 한 문장으로 정리된다.</p> <h3 id="모두가-공존하는-공정한-세상을-위해-작은-움직임들을-만든다">“모두가 공존하는 공정한 세상을 위해 작은 움직임들을 만든다”</h3> <p>그동안 내게 어떤 가치관이 중요하고, 나는 어떤 사람인가에 대해 잘 알고 있다고 생각했는데 새로운 발견이 있던 시간이었다. 나의 가치를 경험과 연결지어 하나씩 정리하면서 두루뭉술한 구름 같던 나라는 사람이 조금 더 또렷하게 느껴졌다. 또 참석한 분들과 각자의 내용을 공유하면서 미처 생각하지 못한 지점을 발견하고 나를 다시 돌아볼 수 있었다. 평소 멋지다고 생각했던 ‘<a href="https://www.staircrusher.club/">계단뿌셔클럽</a>‘에서 활동하는 닷님이 참석하셔서 여러 이야기를 나눌 수 있었는데 동기부여를 팍팍 받았다. <em>(참고로, 임닷커에서는 서로의 이름에 ‘닷’을 붙여 부른다. 나는 ‘슬닷’!)</em></p> <p>무엇보다 ‘Part 2 - 나의 가치 실현하기’에서는 앞서 발견한 나의 가치관을 임닷커에서 어떻게 실현해볼지 고민하게 되는데 이 지점이 정말 감탄스러웠다. <br/> ‘발견한 여러분의 가치관을 바로 이곳, 임닷커에서 실행해 보세요!’라는 메시지를 이렇게 자연스럽게 이끌어내다니!</p> <h2 id="summary">Summary</h2> <p>많은 커뮤니티 활동을 해본 건 아니지만, 이렇게 멋진 오리엔테이션은 처음이었다. 무언가에 꽂히면 그것만 보이는 나는 이미 이곳에 단단히 반해버렸다. 멋진 사람들이 모이는 멋진 커뮤니티가 될 것 같은 예감이 든다.<br/> 내 가치관과 비슷한 결의 사람을 만나는 건 굉장히 어려운 일인데, 다양한 분야에서 활동하는 멋진 사람들을 만나게 되리라는 기대가 생긴다. 함께 공부하며 기획하고 성장하는 커뮤니티가 되도록 즐겁게 활동해보고 싶다.</p> <blockquote> <p>앞으로의 임팩트닷커리어 커뮤니티 활동이 너무나 기대된다!</p> </blockquote>]]></content><author><name></name></author><category term="diary"/><category term="impact.career"/><category term="social-impact"/><category term="community"/><summary type="html"><![CDATA[앞으로 임팩트닷커리어 커뮤니티 오리엔테이션을 참석하는 분들을 위한 생생한 참석 후기]]></summary></entry></feed>